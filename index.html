<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tier List Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Library to render DOM elements to a canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }
        /* Custom styles for color input */
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.125rem; }
        input[type="color"] { -webkit-appearance: none; width: 2.5rem; height: 2.5rem; border: none; background: none; cursor: pointer; border-radius: 0.125rem; }
        
        /* Drag and Drop Visual Feedback */
        .drag-over-item { outline: 3px dashed #60A5FA !important; outline-offset: 2px; z-index: 10; }
        .drag-over-tier-area { background-color: rgba(79, 70, 229, 0.1) !important; }
        
        /* Tier Label Dragging Styles */
        .tier-label-draggable { cursor: grab !important; }
        .tier-label-dragging { opacity: 0.5; }
        .tier-row-drop-target { border-top: 3px dashed #4F46E5 !important; border-bottom: 3px dashed #4F46E5 !important; }
        
        /* Resize Handle Styles */
        .resize-handle-x { position: absolute; right: -5px; top: 0; width: 10px; height: 100%; cursor: col-resize; z-index: 50; }
        .resize-handle-x-visual { width: 4px; height: 100%; background-color: #4B5563; border-radius: 2px; position: absolute; right: 3px; }
        .dark .resize-handle-x-visual { background-color: #6B7280; }

        .resize-handle-y { position: absolute; left: 0; top: -5px; width: 100%; height: 10px; cursor: row-resize; z-index: 50; }
        .resize-handle-y-visual { width: 100%; height: 4px; background-color: #4B5563; border-radius: 2px; position: absolute; top: 3px; }
        .dark .resize-handle-y-visual { background-color: #6B7280; }


        /* Toggle Switch Styles */
        .toggle-checkbox:checked { right: 0; border-color: #4F46E5; }
        .toggle-checkbox:checked + .toggle-label { background-color: #4F46E5; }

        /* Accessibility Focus & Selection Styles */
        *:focus-visible {
            outline: 3px solid #60A5FA;
            outline-offset: 2px;
            border-radius: 2px;
        }
        .keyboard-selected {
            outline: 3px solid #4F46E5 !important;
            outline-offset: 2px;
            border-radius: 2px;
            box-shadow: 0 0 10px #4F46E5;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo, memo } = React;

        // --- ICONS ---
        const PlusCircleIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 8v8"/><path d="M8 12h8"/></svg>;
        const ListIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>;
        const Trash2Icon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V6"/><path d="M8 6V4c0-1.1.9-2 2-2h4c1.1 0 2 .9 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
        const SunIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M4.93 19.07l1.41-1.41"/><path d="M17.66 6.34l1.41-1.41"/></svg>;
        const MoonIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>;
        const PencilIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>;
        const ChevronUpIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m18 15-6-6-6 6"/></svg>;
        const ChevronDownIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m6 9 6 6 6-6"/></svg>;
        const SettingsIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const FileTextIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>;
        const RotateCcwIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>;
        const MaximizeIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>;
        const MinimizeIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>;
        const DownloadIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const UploadIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const XIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;
        const ImageIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>;
        const HelpCircleIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>;
        const ArrowDownToLineIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/></svg>;
        const ArrowRightToLineIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M17 12H3"/><path d="m11 18 6-6-6-6"/><path d="M21 5v14"/></svg>;

        // --- STATE VALIDATION & SERIALIZATION ---
        const validateStateData = (parsedData) => {
            if (parsedData && typeof parsedData === 'object' && !Array.isArray(parsedData)) {
                const validatedData = {
                    ...parsedData,
                    tiers: Array.isArray(parsedData.tiers) ? parsedData.tiers.map(tier => ({ ...tier, items: Array.isArray(tier.items) ? tier.items : [] })) : undefined,
                    items: Array.isArray(parsedData.items) ? parsedData.items : undefined,
                    itemWidth: parsedData.itemWidth || 80,
                    itemHeight: parsedData.itemHeight || 80,
                    containerWidth: parsedData.containerWidth || window.innerWidth,
                    itemPoolTitle: parsedData.itemPoolTitle || "Item Pool",
                    tierLabelWidth: parsedData.tierLabelWidth || 128,
                    tierListTitle: parsedData.tierListTitle || "My Tier List"
                };

                if (validatedData.tiers && validatedData.items) {
                    const validItemIds = new Set(validatedData.items.map(i => i.id));
                    validatedData.tiers = validatedData.tiers.map(tier => ({ ...tier, items: tier.items.filter(id => validItemIds.has(id)) }));
                    const validTierIds = new Set(validatedData.tiers.map(t => t.id));
                    validatedData.items = validatedData.items.map(item => ({ ...item, tierId: validTierIds.has(item.tierId) ? item.tierId : null }));
                }

                return { data: validatedData, error: null };
            }
            return { data: null, error: { message: "Invalid state structure from URL.", type: "warning" } };
        };

        const serializeState = (stateData) => {
            try { return encodeURIComponent(JSON.stringify(stateData)); }
            catch (error) { console.error("Error serializing state:", error); return ""; }
        };

        const deserializeState = (encodedStringFromHash) => {
            if (!encodedStringFromHash) return { data: null, error: null };
            try {
                const parsedData = JSON.parse(decodeURIComponent(encodedStringFromHash));
                return validateStateData(parsedData);
            } catch (e) {
                return { data: null, error: { message: `Error parsing URL state: ${e.message}`, type: "error" } };
            }
        };

        // --- UI COMPONENTS ---

        const DraggableItem = memo(({ item, itemWidth, itemHeight, theme, draggedItemId, draggedOverItemId, handlers, addLog, deleteMode, selectedItemId }) => (
            <div
                id={`item-${item.id}`}
                tabIndex={0}
                role="button"
                aria-pressed={selectedItemId === item.id}
                aria-label={`Item: ${item.value || 'image'}. ${item.tierId ? `In tier ${item.tierId}` : 'In item pool'}. Press Space or Enter to select.`}
                draggable={true}
                onClick={() => handlers.handleItemClick(item.id)}
                onDragStart={(e) => handlers.handleItemDragStart(e, item.id)}
                onDragEnter={(e) => handlers.handleItemDragEnter(e, item.id, item.tierId)}
                onDragOver={(e) => handlers.handleItemDragOver(e, item.id, item.tierId)}
                onDragLeave={(e) => handlers.handleItemDragLeave(e, item.id)}
                onDrop={(e) => handlers.handleItemDrop(e, item.tierId, item.id)}
                onDragEnd={handlers.cleanupDragStates}
                style={{ width: `${itemWidth}px`, height: `${itemHeight}px` }}
                className={`relative z-10 cursor-grab active:cursor-grabbing
                        ${draggedItemId === item.id ? 'opacity-30' : ''}
                        ${selectedItemId === item.id ? 'keyboard-selected' : ''}`}
            >
                <div
                    className={`w-full h-full flex items-center justify-center overflow-hidden ${theme.itemBg} border ${theme.borderColor} rounded-sm shadow-sm transition-all duration-200
                    ${draggedItemId === item.id ? 'ring-2 ring-indigo-500' : ''}
                    ${draggedOverItemId === item.id && draggedItemId !== item.id ? 'drag-over-item' : ''}`}
                >
                    {item.type === 'image' ? (
                        <img src={item.value} alt={item.value || "Item"} className="w-full h-full object-contain pointer-events-none" crossOrigin="anonymous" onError={(e) => { e.target.onerror = null; e.target.src = `https://placehold.co/${itemWidth}x${itemHeight}/FF0000/FFFFFF?text=Error`; e.target.alt = "Image failed"; addLog(`Failed image: ${item.value}`, "error"); }} />
                    ) : (
                        <span className={`text-sm font-medium ${theme.inputText} text-center p-1 break-all pointer-events-none`}>{item.value}</span>
                    )}
                </div>
                <button
                    onClick={(e) => { e.stopPropagation(); handlers.handleDeleteItem(item.id); }}
                    className={`absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-1 z-20 transition-opacity ${deleteMode ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
                    aria-label={`Delete item ${item.value}`}
                >
                    <Trash2Icon size={14} />
                </button>
            </div>
        ));

        const TierRow = ({ tier, items, theme, dragState, handlers, itemProps, index, totalTiers, deleteMode, selectedTierId }) => {
            const { draggedTierId, draggedOverTierRowId, draggedOverTierAreaId, draggedItemId, draggedOverItemId, selectedItemId } = dragState;
            const tierItems = tier.items.map(itemId => items.find(i => i.id === itemId)).filter(Boolean);

            return (
                <div
                    onDragOver={(e) => handlers.handleTierRowDragOver(e, tier.id)}
                    onDragLeave={(e) => handlers.handleTierRowDragLeave(e, tier.id)}
                    onDrop={(e) => handlers.handleTierDrop(e, tier.id)}
                    className={`flex items-stretch min-h-[100px] transition-all duration-200
                            ${draggedOverTierRowId === tier.id && draggedTierId && draggedTierId !== tier.id ? 'tier-row-drop-target' : ''}`}
                >
                    <div
                        id={`tier-label-${tier.id}`}
                        tabIndex={0}
                        role="button"
                        aria-pressed={selectedTierId === tier.id}
                        aria-label={`Tier: ${tier.value}. Press Space or Enter to select.`}
                        onClick={() => handlers.handleTierClick(tier.id)}
                        draggable={true}
                        onDragStart={(e) => handlers.handleTierLabelDragStart(e, tier.id)}
                        onDragEnd={handlers.cleanupDragStates}
                        className={`relative flex-shrink-0 p-3 flex items-center justify-center text-center font-bold text-lg text-black group tier-label-draggable ${draggedTierId === tier.id ? 'tier-label-dragging' : ''} ${selectedTierId === tier.id ? 'keyboard-selected' : ''}`}
                        style={{ backgroundColor: tier.color, width: `${itemProps.tierLabelWidth}px` }}
                    >
                        <span className="pointer-events-none">{tier.value}</span>
                        <>
                            <button onClick={(e) => { e.stopPropagation(); handlers.handleDeleteTier(tier.id); }} className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 z-10" aria-label={`Delete tier ${tier.value}`}> <Trash2Icon size={14} /> </button>
                            <button onClick={(e) => { e.stopPropagation(); handlers.startEditingTier(tier); }} className="absolute top-1 left-1 bg-gray-600 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 z-10" aria-label={`Edit tier ${tier.value}`}> <PencilIcon size={14} /> </button>
                        </>
                    </div>
                    <div
                        onDragEnter={(e) => handlers.handleTierAreaDragEnter(e, tier.id)}
                        onDragOver={(e) => handlers.handleTierAreaDragOver(e, tier.id)}
                        onDragLeave={(e) => handlers.handleTierAreaDragLeave(e, tier.id)}
                        onDrop={(e) => handlers.handleItemDrop(e, tier.id, null)}
                        className={`flex-grow p-2 flex flex-wrap gap-2 items-start justify-start min-h-[100px] ${theme.containerBg}
                            ${draggedOverTierAreaId === tier.id && draggedItemId && !draggedOverItemId ? 'drag-over-tier-area' : ''}`}
                        aria-label={`Tier ${tier.value} content area`}
                    >
                        {tierItems.map(item => <DraggableItem key={item.id} item={item} {...itemProps} theme={theme} deleteMode={deleteMode} draggedItemId={draggedItemId} draggedOverItemId={draggedOverItemId} handlers={handlers} addLog={handlers.addLog} selectedItemId={selectedItemId} />)}
                    </div>
                </div>
            );
        };

        const ItemPool = ({ items, itemPoolTitle, setItemPoolTitle, theme, dragState, handlers, itemProps, deleteMode, poolPosition, onTogglePosition }) => {
            const { draggedOverTierAreaId, draggedItemId, draggedOverItemId, selectedItemId } = dragState;
            const unassignedItems = items.filter(item => item.tierId === null);

            const isSideLayout = poolPosition === 'right';

            return (
                <div
                    onDragEnter={(e) => handlers.handleTierAreaDragEnter(e, null)}
                    onDragOver={(e) => handlers.handleTierAreaDragOver(e, null)}
                    onDragLeave={(e) => handlers.handleTierAreaDragLeave(e, null)}
                    onDrop={(e) => handlers.handleItemDrop(e, null, null)}
                    className={`relative p-4 flex flex-col ${theme.containerBg}
                            ${draggedOverTierAreaId === null && draggedItemId ? 'drag-over-tier-area' : ''}
                            ${isSideLayout ? 'h-full' : 'min-h-[150px] w-full'}`}
                    aria-label="Item Pool area"
                >
                    <div className={`text-xl font-semibold ${theme.text} mb-3 flex items-center justify-center gap-2`}>
                        <input
                            type="text"
                            value={itemPoolTitle}
                            onChange={(e) => setItemPoolTitle(e.target.value)}
                            className={`bg-transparent border-none focus:outline-none focus:ring-0 text-center p-0 font-semibold ${theme.text}`}
                            aria-label="Item pool title"
                        />
                    </div>
                    <div className={`flex flex-wrap gap-2 justify-center sm:justify-start flex-grow ${isSideLayout ? 'overflow-y-auto p-2' : 'min-h-[100px]'}`}>
                        {unassignedItems.map(item => <DraggableItem key={item.id} item={item} {...itemProps} theme={theme} deleteMode={deleteMode} draggedItemId={draggedItemId} draggedOverItemId={draggedOverItemId} handlers={handlers} addLog={handlers.addLog} selectedItemId={selectedItemId} />)}
                    </div>
                    <div className="absolute bottom-4 right-4 flex gap-2">
                         { window.innerWidth >= 1280 &&
                            <button onClick={onTogglePosition} className={`w-12 h-12 rounded-full shadow-lg flex items-center justify-center ${theme.darkMode ? 'bg-gray-600 hover:bg-gray-700' : 'bg-gray-400 hover:bg-gray-500'} ${theme.buttonText}`} aria-label={isSideLayout ? "Move item pool to bottom" : "Move item pool to right"}>
                                {isSideLayout ? <ArrowDownToLineIcon size={24} /> : <ArrowRightToLineIcon size={24} />}
                            </button>
                        }
                        <button onClick={handlers.handleResetAllItemsToPool} className={`w-12 h-12 rounded-full shadow-lg flex items-center justify-center ${theme.darkMode ? 'bg-red-700 hover:bg-red-800' : 'bg-red-500 hover:bg-red-600'} ${theme.buttonText}`} aria-label="Reset all items to pool"><RotateCcwIcon size={24}/></button>
                    </div>
                </div>
            );
        };

        const CommandsPopover = ({ theme, onClose }) => {
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        onClose();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [onClose]);

            const commands = [
                { keys: ['/', '?'], desc: 'Toggle this help menu' },
                { keys: ['Space', 'Enter'], desc: 'Select / Deselect an item or tier' },
                { keys: ['Esc'], desc: 'Deselect current item or tier' },
                { keys: ['W', '↑'], desc: 'Navigate up / Move item up a tier / Move tier up' },
                { keys: ['A', '←'], desc: 'Navigate left / Move item left within tier' },
                { keys: ['S', '↓'], desc: 'Navigate down / Move item down a tier / Move tier down' },
                { keys: ['D', '→'], desc: 'Navigate right / Move item right within tier' },
                { keys: ['N', 'E'], desc: 'Select next item in Item Pool' },
                { keys: ['F'], desc: 'Toggle fullscreen mode' },
            ];

            return (
                <div
                    className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50"
                    onClick={onClose}
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="commands-title"
                >
                    <div
                        className={`relative w-full max-w-lg p-6 rounded-sm shadow-xl ${theme.containerBg}`}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <button
                            onClick={onClose}
                            className={`absolute top-4 right-4 p-2 rounded-full ${theme.darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-200'}`}
                            aria-label="Close keyboard commands"
                        >
                            <XIcon size={24} className={theme.text} />
                        </button>
                        <h2 id="commands-title" className={`text-2xl font-bold mb-4 ${theme.text}`}>Keyboard Commands ⌨️</h2>
                        <div className="space-y-3">
                            {commands.map((cmd, i) => (
                                <div key={i} className={`flex justify-between items-center p-2 rounded ${theme.sectionBg}`}>
                                    <span className={`font-mono text-sm ${theme.inputText}`}>
                                        {cmd.keys.map(key => (
                                            <kbd key={key} className={`px-2 py-1 mr-1 rounded-md border ${theme.borderColor} ${theme.darkMode ? 'bg-gray-900' : 'bg-gray-100'}`}>
                                                {key}
                                            </kbd>
                                        ))}
                                    </span>
                                    <span className={`text-sm ${theme.text}`}>{cmd.desc}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const ConfigurationPanel = ({ theme, uiState, uiSetters, data, dataHandlers, editState, editSetters, refs, itemProps, itemSetters, deleteMode, setDeleteMode, setContainerWidth, toggleFullScreen, setDarkMode, isFullscreen, darkMode }) => {
            const { showConfiguration, editingTierId, showLogs } = uiState;
            const { setShowConfiguration, setShowLogs, handleSelectFirstItemInPool } = uiSetters;
            const { logs, standardColors } = data;
            const { handleAddTier, handleAddItem, handlePasteItems, handleSaveEditedTier, cancelEditingTier, addLog } = dataHandlers;
            const { editingTierLabel, editingTierColor, newTierColor } = editState;
            const { setEditingTierLabel, setEditingTierColor, setNewTierColor } = editSetters;
            const { newTierNameRef, newItemNameRef, newItemImageFileRef, newItemImageUrlRef, pasteItemsRef, importFileRef, logDisplayRef } = refs;
            const { itemWidth, itemHeight, tierLabelWidth } = itemProps;
            const { setItemWidth, setItemHeight, setTierLabelWidth } = itemSetters;

            const [localWidth, setLocalWidth] = useState(itemWidth);
            const [localHeight, setLocalHeight] = useState(itemHeight);
            const [localTierLabelWidth, setLocalTierLabelWidth] = useState(tierLabelWidth);

            useEffect(() => {
                setLocalWidth(itemWidth);
                setLocalHeight(itemHeight);
                setLocalTierLabelWidth(tierLabelWidth);
            }, [itemWidth, itemHeight, tierLabelWidth]);

            const handleSizeUpdate = () => {
                const newWidth = Math.max(20, parseInt(localWidth) || 80);
                const newHeight = Math.max(20, parseInt(localHeight) || 80);
                const newLabelWidth = Math.max(40, parseInt(localTierLabelWidth) || 128);
                setItemWidth(newWidth);
                setItemHeight(newHeight);
                setTierLabelWidth(newLabelWidth);
                addLog(`Sizes updated: Item ${newWidth}x${newHeight}, Label ${newLabelWidth}`, 'info');
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleSizeUpdate();
                    e.target.blur();
                }
            };

            const handleHexColorChange = (e, isEditing) => {
                const hex = e.target.value;
                if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {
                    if (isEditing) setEditingTierColor(hex); else setNewTierColor(hex);
                }
            };

            const copyLogsToClipboard = () => {
                const logText = logs.map(l => `[${l.timestamp}] [${l.type.toUpperCase()}] ${l.message}`).join('\n');
                if (logText) navigator.clipboard.writeText(logText).then(()=> addLog("Logs copied.", "info")).catch(()=> addLog("Clipboard copy failed.", "error"));
                else addLog("No logs to copy.", "info");
            };

            const selectAllLogs = () => {
                if (logDisplayRef.current) {
                    const range = document.createRange();
                    range.selectNodeContents(logDisplayRef.current);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            };

            const handleConfigToggle = () => {
                if (showConfiguration) { // If it's currently open and about to close
                    handleSelectFirstItemInPool();
                    window.scrollTo(0, 0);
                }
                setShowConfiguration(!showConfiguration);
            }

            return (
                <div className="flex flex-col gap-1">
                    <div className={`${theme.containerBg} p-4`}>
                        <h2 className={`text-2xl font-bold ${theme.text} mb-4 text-center flex items-center justify-center gap-2`}>
                            <SettingsIcon size={24} /> Configuration
                            <button onClick={handleConfigToggle} className={`p-1 rounded-full ${theme.darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-300 hover:bg-gray-400'}`} aria-expanded={showConfiguration}> {showConfiguration ? <ChevronUpIcon size={20} /> : <ChevronDownIcon size={20} />} </button>
                        </h2>
                        {showConfiguration && (
                            <>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-1">
                                    {/* General Settings */}
                                    <div className={`${theme.sectionBg} p-3 rounded-sm md:col-span-2 lg:col-span-3`}>
                                        <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-purple-300':'text-purple-600'} mb-3 flex items-center gap-2`}> <SettingsIcon size={20}/> General Settings</h3>
                                        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4">
                                            <button onClick={() => setContainerWidth(window.innerWidth)} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}>
                                                Fit to Screen
                                            </button>
                                            <button onClick={toggleFullScreen} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}>
                                                {isFullscreen ? <MinimizeIcon size={20} /> : <MaximizeIcon size={20} />}
                                                {isFullscreen ? "Exit Fullscreen" : "Fullscreen"}
                                            </button>
                                            <button onClick={() => setDarkMode(!darkMode)} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}>
                                                {darkMode ? <SunIcon size={20} /> : <MoonIcon size={20} />}
                                                {darkMode ? "Light Mode" : "Dark Mode"}
                                            </button>
                                        </div>
                                        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 items-end pt-4 border-t border-gray-200 dark:border-gray-700">
                                            <div>
                                                <label htmlFor="tierLabelWidth" className={`block text-sm font-medium ${theme.inputText}`}>Category Width (px)</label>
                                                <input type="number" id="tierLabelWidth" value={localTierLabelWidth} onChange={e => setLocalTierLabelWidth(e.target.value)} onKeyDown={handleKeyDown} className={`mt-1 p-2 w-full border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            </div>
                                            <div>
                                                <label htmlFor="itemWidth" className={`block text-sm font-medium ${theme.inputText}`}>Item Width (px)</label>
                                                <input type="number" id="itemWidth" value={localWidth} onChange={e => setLocalWidth(e.target.value)} onKeyDown={handleKeyDown} className={`mt-1 p-2 w-full border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            </div>
                                            <div>
                                                <label htmlFor="itemHeight" className={`block text-sm font-medium ${theme.inputText}`}>Item Height (px)</label>
                                                <input type="number" id="itemHeight" value={localHeight} onChange={e => setLocalHeight(e.target.value)} onKeyDown={handleKeyDown} className={`mt-1 p-2 w-full border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            </div>
                                            <div className="sm:col-span-2 lg:col-span-3 mt-2 grid grid-cols-1 sm:grid-cols-2 gap-4">
                                                <button onClick={handleSizeUpdate} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText}`}>Update Sizes</button>
                                                <div className="flex justify-center items-center">
                                                    <label htmlFor="deleteModeToggle" className={`text-sm font-medium ${theme.inputText} mr-3`}>Delete Mode</label>
                                                    <div className="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                                        <input type="checkbox" name="toggle" id="deleteModeToggle" checked={deleteMode} onChange={() => setDeleteMode(!deleteMode)} className="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                                        <label htmlFor="deleteModeToggle" className="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    {/* Edit/Create Tier */}
                                    {editingTierId ? (
                                        <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                            <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-indigo-300':'text-indigo-600'} mb-2 flex items-center gap-2`}> <PencilIcon size={20}/> Edit Tier</h3>
                                            <input type="text" value={editingTierLabel} onChange={e=>setEditingTierLabel(e.target.value)} placeholder="Label" className={`w-full p-2 mb-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <div className="flex items-center gap-2 mb-2"> {standardColors.map(c=><button key={c} onClick={()=>setEditingTierColor(c)} className={`w-7 h-7 rounded-full border-2 ${editingTierColor===c?(theme.darkMode?'border-white':'border-black'):'border-transparent'}`} style={{backgroundColor:c}} aria-label={`Set color to ${c}`}/>)} </div>
                                            <div className="flex items-center gap-2 mb-3">
                                                <input type="color" value={editingTierColor} onChange={e=>setEditingTierColor(e.target.value)} className={`w-9 h-9 rounded-sm ${theme.darkMode?'border-gray-600':'border-gray-400'} border`} aria-label="Custom color picker"/>
                                                <input type="text" value={editingTierColor} onChange={e=>handleHexColorChange(e,true)} placeholder="#hex" className={`p-2 w-28 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`} aria-label="Hex color value"/>
                                            </div>
                                            <div className="flex gap-2"><button onClick={handleSaveEditedTier} className={`flex-1 py-2 ${theme.darkMode?'bg-indigo-600 hover:bg-indigo-700':'bg-indigo-500 hover:bg-indigo-600'} ${theme.buttonText} rounded-sm`}>Save</button> <button onClick={cancelEditingTier} className={`flex-1 py-2 ${theme.buttonSecondaryBg} ${theme.buttonText} rounded-sm`}>Cancel</button></div>
                                        </div>
                                    ) : (
                                        <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                            <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-blue-300':'text-blue-600'} mb-2 flex items-center gap-2`}> <PlusCircleIcon size={20}/> Create Tier</h3>
                                            <input type="text" ref={newTierNameRef} placeholder="Label" className={`w-full p-2 mb-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <div className="flex items-center gap-2 mb-2"> {standardColors.map(c=><button key={c} onClick={()=>setNewTierColor(c)} className={`w-7 h-7 rounded-full border-2 ${newTierColor===c?(theme.darkMode?'border-white':'border-black'):'border-transparent'}`} style={{backgroundColor:c}} aria-label={`Set color to ${c}`}/>)} </div>
                                            <div className="flex items-center gap-2 mb-3">
                                                <input type="color" value={newTierColor} onChange={e=>setNewTierColor(e.target.value)} className={`w-9 h-9 rounded-sm ${theme.darkMode?'border-gray-600':'border-gray-400'} border`} aria-label="Custom color picker"/>
                                                <input type="text" value={newTierColor} onChange={e=>handleHexColorChange(e,false)} placeholder="#hex" className={`p-2 w-28 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`} aria-label="Hex color value"/>
                                            </div>
                                            <button onClick={handleAddTier} className={`w-full py-2 ${theme.buttonPrimaryBg} ${theme.buttonText} rounded-sm`}>Add Tier</button>
                                        </div>
                                    )}
                                    {/* Add Item */}
                                    <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                        <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-green-300':'text-green-600'} mb-3 flex items-center gap-2`}> <PlusCircleIcon size={20}/> Add Item</h3>
                                        <div className="flex flex-col gap-3">
                                            <input type="text" ref={newItemNameRef} placeholder="Name" className={`w-full p-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <input type="text" ref={newItemImageUrlRef} placeholder="Image URL" className={`w-full p-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <div className="flex flex-col gap-2 pt-1">
                                                <label className={`w-full py-2 px-4 text-center rounded-sm cursor-pointer ${theme.darkMode?'bg-green-600/80 hover:bg-green-700/80':'bg-green-500/80 hover:bg-green-600/80'} ${theme.buttonText}`}>
                                                    Select Image(s) From Device
                                                    <input type="file" ref={newItemImageFileRef} accept="image/*" multiple onChange={dataHandlers.handleItemImageUpload} className="hidden"/>
                                                </label>
                                                <button onClick={handleAddItem} className={`w-full py-2 ${theme.darkMode?'bg-green-600 hover:bg-green-700':'bg-green-500 hover:bg-green-600'} ${theme.buttonText} rounded-sm`}>Add Text/URL Item</button>
                                            </div>
                                        </div>
                                    </div>
                                    {/* Paste Items */}
                                    <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                        <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-yellow-300':'text-yellow-600'} mb-2 flex items-center gap-2`}> <ListIcon size={20}/> Paste Items</h3>
                                        <textarea ref={pasteItemsRef} rows="5" placeholder="One per line" className={`w-full p-2 mb-3 border ${theme.borderColor} rounded-sm resize-y ${theme.inputBg} ${theme.inputText}`}></textarea>
                                        <button onClick={handlePasteItems} className={`w-full py-2 ${theme.darkMode?'bg-yellow-600 hover:bg-yellow-700':'bg-yellow-500 hover:bg-yellow-600'} ${theme.buttonText} rounded-sm`}>Add Pasted</button>
                                    </div>
                                    {/* Data Management */}
                                    <div className={`${theme.sectionBg} p-3 rounded-sm lg:col-span-3`}>
                                        <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-cyan-300':'text-cyan-600'} mb-2 flex items-center gap-2`}>
                                            <DownloadIcon size={20}/> Data Management
                                        </h3>
                                        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                            <input
                                                type="file"
                                                ref={importFileRef}
                                                onChange={dataHandlers.handleImportState}
                                                className="hidden"
                                            />
                                            <button
                                                onClick={() => importFileRef.current.click()}
                                                className={`flex-1 py-2 ${theme.darkMode?'bg-cyan-600 hover:bg-cyan-700':'bg-cyan-500 hover:bg-cyan-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                            >
                                                <UploadIcon size={20} /> Import
                                            </button>
                                            <button
                                                onClick={dataHandlers.handleExportState}
                                                className={`flex-1 py-2 ${theme.darkMode?'bg-cyan-600 hover:bg-cyan-700':'bg-cyan-500 hover:bg-cyan-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                            >
                                                <DownloadIcon size={20} /> Export
                                            </button>
                                            <button
                                                onClick={dataHandlers.handleExportImage}
                                                className={`flex-1 py-2 ${theme.darkMode?'bg-teal-600 hover:bg-teal-700':'bg-teal-500 hover:bg-teal-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                            >
                                                <ImageIcon size={20} /> Export Image
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                {/* Logs Section */}
                                <div className="mt-1">
                                    <div className={`${theme.containerBg} p-4`}>
                                        <h3 className={`text-xl font-semibold ${theme.text} mb-3 text-center flex items-center justify-center gap-2`}>
                                            <FileTextIcon size={20} /> Application Logs
                                            <button onClick={()=>setShowLogs(!showLogs)} className={`p-1 rounded-full ${theme.darkMode?'bg-gray-700 hover:bg-gray-600':'bg-gray-300 hover:bg-gray-400'}`} aria-expanded={showLogs}>{showLogs?<ChevronUpIcon size={18}/>:<ChevronDownIcon size={18}/>}</button>
                                        </h3>
                                        {showLogs && (<>
                                            <div className="flex gap-2 mb-3">
                                                <button onClick={copyLogsToClipboard} className={`flex-1 py-1.5 px-3 rounded-sm ${theme.darkMode?'bg-gray-700 hover:bg-gray-600':'bg-gray-300 hover:bg-gray-400'}`}>Copy</button>
                                                <button onClick={selectAllLogs} className={`flex-1 py-1.5 px-3 rounded-sm ${theme.darkMode?'bg-gray-700 hover:bg-gray-600':'bg-gray-300 hover:bg-gray-400'}`}>Select</button>
                                            </div>
                                            <div ref={logDisplayRef} className={`log-display-area flex flex-col gap-1 ${theme.sectionBg} p-3 rounded-sm border ${theme.borderColor} max-h-60 overflow-y-auto text-left`}>
                                                {logs.length === 0 ? <p className={`${theme.darkMode?'text-gray-400':'text-gray-600'} text-sm`}>No logs.</p> : logs.map((l,i)=>(
                                                    <p key={i} className={`text-xs font-mono ${l.type==='error'?(theme.darkMode?'text-red-400':'text-red-600'):l.type==='warning'?(theme.darkMode?'text-yellow-400':'text-yellow-600'):l.type==='action'?(theme.darkMode?'text-blue-300':'text-blue-600'):l.type==='event'?(theme.darkMode?'text-purple-300':'text-purple-600'):(theme.darkMode?'text-gray-300':'text-gray-700')}`}>
                                                        <span className={`${theme.darkMode?'text-gray-500':'text-gray-400'}`}>{l.timestamp}</span> <span className={`font-bold ${l.type==='error'?(theme.darkMode?'text-red-500':'text-red-700'):l.type==='warning'?(theme.darkMode?'text-yellow-500':'text-yellow-700'):l.type==='action'?(theme.darkMode?'text-blue-400':'text-blue-700'):l.type==='event'?(theme.darkMode?'text-purple-400':'text-purple-700'):(theme.darkMode?'text-gray-400':'text-gray-500')}`}>[{l.type.toUpperCase()}]</span> {l.message}
                                                    </p>
                                                ))}
                                            </div></>
                                        )}
                                    </div>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        function App() {
            // --- STATE MANAGEMENT ---
            const [darkMode, setDarkMode] = useState(true);
            const [logs, setLogs] = useState([]);
            const [announcement, setAnnouncement] = useState("");
            const addLog = useCallback((message, type = 'info') => setLogs(prev => [{ message, type, timestamp: new Date().toLocaleTimeString() }, ...prev].slice(0, 100)), []);

            const initialDeserializedResult = deserializeState(window.location.hash.substring(1));
            const initialData = initialDeserializedResult.data;

            const [tiers, setTiers] = useState(initialData?.tiers || [
                { id: 's', type: 'name', value: 'S', items: [], color: '#ff7f7f' }, { id: 'a', type: 'name', value: 'A', items: [], color: '#ffbf7f' },
                { id: 'b', type: 'name', value: 'B', items: [], color: '#ffff7f' }, { id: 'c', type: 'name', value: 'C', items: [], color: '#bfff7f' },
                { id: 'd', type: 'name', value: 'D', items: [], color: '#7fbfff' },
                { id: 'f', type: 'name', value: 'F', items: [], color: '#bf7fff' },
            ]);
            const [items, setItems] = useState(initialData?.items || []);
            const [tierListTitle, setTierListTitle] = useState(initialData?.tierListTitle || 'My Tier List');
            const [itemPoolTitle, setItemPoolTitle] = useState(initialData?.itemPoolTitle || 'Item Pool');
            const [itemWidth, setItemWidth] = useState(initialData?.itemWidth || 80);
            const [itemHeight, setItemHeight] = useState(initialData?.itemHeight || 80);
            const [tierLabelWidth, setTierLabelWidth] = useState(initialData?.tierLabelWidth || 128);
            const [deleteMode, setDeleteMode] = useState(false);
            const [isFullscreen, setIsFullscreen] = useState(false);
            
            const [showConfiguration, setShowConfiguration] = useState(true);
            const [showLogs, setShowLogs] = useState(false);
            const [showCommandsPopover, setShowCommandsPopover] = useState(false);

            // Layout state
            const [poolPosition, setPoolPosition] = useState('bottom');
            const [manualPoolPosition, setManualPoolPosition] = useState(false);
            const [tierListPanelWidth, setTierListPanelWidth] = useState(65); // Percentage
            const [isResizing, setIsResizing] = useState(false);

            const [draggedItemId, setDraggedItemId] = useState(null);
            const [draggedTierId, setDraggedTierId] = useState(null);
            const [draggedOverItemId, setDraggedOverItemId] = useState(null);
            const [draggedOverTierRowId, setDraggedOverTierRowId] = useState(null);
            const [draggedOverTierAreaId, setDraggedOverTierAreaId] = useState(null);

            // A11y State
            const [selectedItemId, setSelectedItemId] = useState(null);
            const [selectedTierId, setSelectedTierId] = useState(null);
            const lastManuallySelectedId = useRef(null);
            const lastMovedTierId = useRef(null);

            const [editingTierId, setEditingTierId] = useState(null);
            const [editingTierLabel, setEditingTierLabel] = useState('');
            const [editingTierColor, setEditingTierColor] = useState('#888888');
            const [newTierColor, setNewTierColor] = useState('#888888');

            const newTierNameRef = useRef(null);
            const newItemNameRef = useRef(null); const newItemImageFileRef = useRef(null); const newItemImageUrlRef = useRef(null);
            const pasteItemsRef = useRef(null);
            const appContainerRef = useRef(null);
            const importFileRef = useRef(null);
            const logDisplayRef = useRef(null);
            const tierListRef = useRef(null); // Ref for the element to capture

            const standardColors = ['#ff7f7f', '#ffbf7f', '#ffff7f', '#bfff7f', '#7fbfff', '#bf7fff', '#c0c0c0', '#404040'];
            
            useEffect(() => { document.documentElement.classList.toggle('dark', darkMode); document.body.style.backgroundColor = darkMode ? '#000000' : '#f3f4f6'; }, [darkMode]);

            useEffect(() => {
                const stateToSave = { tiers, items, tierListTitle, itemWidth, itemHeight, itemPoolTitle, tierLabelWidth };
                const hashString = serializeState(stateToSave);
                const id = setTimeout(() => { if (window.location.hash.substring(1) !== hashString) { window.location.hash = hashString; } }, 700);
                return () => clearTimeout(id);
            }, [tiers, items, tierListTitle, itemWidth, itemHeight, itemPoolTitle, tierLabelWidth]);

            useEffect(() => { if (initialDeserializedResult.error) { addLog(initialDeserializedResult.error.message, initialDeserializedResult.error.type); } }, [initialDeserializedResult.error, addLog]);

            const toggleFullScreen = useCallback(() => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }, []);

            useEffect(() => {
                const handleFullScreenChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFullScreenChange);
                return () => document.removeEventListener('fullscreenchange', handleFullScreenChange);
            }, []);

            // Handle responsive layout changes
            useEffect(() => {
                const handleResize = () => {
                    if (!manualPoolPosition) {
                        if (window.innerWidth >= 1280) {
                            setPoolPosition('right');
                        } else {
                            setPoolPosition('bottom');
                        }
                    }
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [manualPoolPosition]);

            const handleTogglePosition = () => {
                setPoolPosition(prev => prev === 'right' ? 'bottom' : 'right');
                setManualPoolPosition(true);
            };


            const generateId = useCallback(() => crypto.randomUUID(), []);

            // --- DATA HANDLERS ---
            const handleExportImage = () => {
                if (tierListRef.current) {
                    addLog('Generating image...', 'info');
                    html2canvas(tierListRef.current, {
                        useCORS: true, // Important for external images
                        allowTaint: true,
                        backgroundColor: darkMode ? '#000000' : '#ffffff', // Use theme background
                        scrollX: 0,
                        scrollY: -window.scrollY
                    }).then(canvas => {
                        const link = document.createElement('a');
                        const fileName = `${tierListTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                        link.download = fileName;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                        addLog(`Image exported as ${fileName}`, 'action');
                    }).catch(err => {
                        addLog(`Image export failed: ${err.message}`, 'error');
                        console.error('html2canvas error:', err);
                    });
                } else {
                    addLog('Tier list element not found for capture.', 'error');
                }
            };

            const handleExportState = () => {
                const stateToSave = { tiers, items, tierListTitle, itemPoolTitle, itemWidth, itemHeight, tierLabelWidth };
                const jsonString = JSON.stringify(stateToSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const fileName = `${tierListTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.tierlist`;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                addLog(`State exported to ${fileName}`, 'action');
            };

            const handleImportState = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parsedData = JSON.parse(e.target.result);
                        const { data, error } = validateStateData(parsedData);

                        if (error) {
                            addLog(error.message, error.type);
                            return;
                        }

                        setTiers(data.tiers || []);
                        setItems(data.items || []);
                        setTierListTitle(data.tierListTitle);
                        setItemPoolTitle(data.itemPoolTitle);
                        setItemWidth(data.itemWidth);
                        setItemHeight(data.itemHeight);
                        setTierLabelWidth(data.tierLabelWidth);

                        const firstUnassignedItem = data.items.find(item => item.tierId === null);
                        if (firstUnassignedItem) {
                            setSelectedItemId(firstUnassignedItem.id);
                        }
                        window.scrollTo(0, 0);
                        addLog('State successfully imported from file.', 'action');

                    } catch (err) {
                        addLog(`Error reading file: ${err.message}`, 'error');
                    } finally {
                        if (importFileRef.current) {
                            importFileRef.current.value = null;
                        }
                    }
                };
                reader.onerror = () => {
                    addLog('Failed to read the file.', 'error');
                };
                reader.readAsText(file);
            };

            const handleItemImageUpload = (event) => {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                addLog(`Processing ${files.length} image(s)...`, 'info');

                let isFirstImage = true;

                Array.from(files).forEach(file => {
                    let newItem = { id: generateId(), tierId: null };
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const maxWidth = itemWidth * 2;
                            const maxHeight = itemHeight * 2;
                            let width = img.width;
                            let height = img.height;
                            if (width > height) { if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; } }
                            else { if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; } }
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            newItem.type = 'image';
                            newItem.value = canvas.toDataURL('image/jpeg', 0.8);
                            setItems(p => [...p, newItem]);
                            if (isFirstImage) {
                                setSelectedItemId(newItem.id);
                                isFirstImage = false;
                            }
                        };
                        img.src = reader.result;
                    };
                    reader.onerror = () => addLog(`Error reading file: ${file.name}`, "error");
                    reader.readAsDataURL(file);
                });

                window.scrollTo(0, 0);
                addLog(`Added ${files.length} items from files.`, 'action');
                if (newItemImageFileRef.current) newItemImageFileRef.current.value = '';
            };

            const handleAddTier = () => {
                const name = newTierNameRef.current.value.trim();
                if (!name) { addLog("Tier name required.", "warning"); return; }
                const newTier = { id: generateId(), items: [], color: newTierColor, type: 'name', value: name };
                setTiers(p => [...p, newTier]);
                addLog(`Added text tier: ${name}`, "info");
                newTierNameRef.current.value = '';
            };

            const handleAddItem = () => {
                const name = newItemNameRef.current.value.trim();
                const url = newItemImageUrlRef.current.value.trim();
                if (!name && !url) { addLog("Item name or URL required.", "warning"); return; }
                let newItem = { id: generateId(), tierId: null };
                if (url) {
                    if (!url.startsWith('http')) { addLog("Invalid item URL.", "error"); return; }
                    newItem.type = 'image'; newItem.value = url; setItems(p => [...p, newItem]); addLog("Added URL item.", "info");
                } else {
                    newItem.type = 'name'; newItem.value = name; setItems(p => [...p, newItem]); addLog(`Added text item: ${name}`, "info");
                }
                newItemNameRef.current.value = '';
                if (newItemImageUrlRef.current) newItemImageUrlRef.current.value = '';
            };
            
            const handleSelectFirstItemInPool = useCallback(() => {
                const unassignedItems = items.filter(item => item.tierId === null);
                if (unassignedItems.length > 0) {
                    const firstItemId = unassignedItems[0].id;
                    handleItemClick(firstItemId);
                    lastManuallySelectedId.current = firstItemId;
                }
            }, [items, handleItemClick]);

            const handlePasteItems = () => {
                const text = pasteItemsRef.current.value.trim(); if (!text) { addLog("Paste area empty.", "warning"); return; }
                const newItems = text.split('\n').map(l => ({ id: generateId(), type: 'name', value: l.trim(), tierId: null })).filter(i => i.value);
                setItems(p => [...p, ...newItems]); addLog(`Pasted ${newItems.length} items.`, "info"); pasteItemsRef.current.value = '';
                window.scrollTo(0, 0);
                handleSelectFirstItemInPool();
            };

            const handleResetAllItemsToPool = () => {
                setItems(prevItems => prevItems.map(item => ({ ...item, tierId: null })));
                setTiers(prevTiers => prevTiers.map(tier => ({ ...tier, items: [] })));
                addLog("All items reset to pool.", "action");
            };

            const handleDeleteItem = (id) => { setItems(p => p.filter(i => i.id !== id)); setTiers(p => p.map(t => ({ ...t, items: t.items.filter(itemId => itemId !== id) }))); addLog(`Deleted item ${id}`, "action"); };
            const handleDeleteTier = (id) => { const tierDel = tiers.find(t=>t.id===id); if(tierDel) setItems(p=>p.map(i=>tierDel.items.includes(i.id)?{...i, tierId:null}:i)); setTiers(p => p.filter(t => t.id !== id)); if(editingTierId===id) cancelEditingTier(); addLog(`Deleted tier ${id}`, "action"); };
            
            const startEditingTier = (tier) => { setEditingTierId(tier.id); setEditingTierLabel(tier.value); setEditingTierColor(tier.color); setShowConfiguration(true); addLog(`Editing tier ${tier.id}`, "info"); };
            
            const handleSaveEditedTier = () => {
                if (!editingTierId) return;
                const updatedValue = editingTierLabel.trim();
                if (updatedValue) {
                    setTiers(p => p.map(t => t.id === editingTierId ? { ...t, value: updatedValue, color: editingTierColor } : t));
                    addLog(`Saved tier ${editingTierId}`, "action");
                    cancelEditingTier();
                } else {
                    addLog("Label cannot be empty.", "warning");
                }
            };

            const cancelEditingTier = () => { setEditingTierId(null); setEditingTierLabel(''); setEditingTierColor('#888888'); addLog("Edit tier cancelled.", "info"); };

            // --- DRAG & DROP + A11Y HANDLERS ---

            useEffect(() => { if (selectedItemId) setSelectedTierId(null); }, [selectedItemId]);
            useEffect(() => { if (selectedTierId) setSelectedItemId(null); }, [selectedTierId]);

            const moveItem = useCallback((itemId, targetTierId, beforeItemId = null) => {
                setItems(prevItems => {
                    const itemToMove = prevItems.find(i => i.id === itemId);
                    if (!itemToMove) return prevItems;
                    const fromTierName = itemToMove.tierId ? tiers.find(t => t.id === itemToMove.tierId)?.value : itemPoolTitle;
                    const toTierName = targetTierId ? tiers.find(t => t.id === targetTierId)?.value : itemPoolTitle;
                    setAnnouncement(`Moved item from ${fromTierName} to ${toTierName}.`);
                    lastManuallySelectedId.current = itemId;
                    return prevItems.map(i => i.id === itemId ? { ...i, tierId: targetTierId } : i);
                });
                setTiers(prevTiers => {
                    let newTiers = prevTiers.map(t => ({ ...t, items: t.items.filter(id => id !== itemId) }));
                    if (targetTierId) {
                        newTiers = newTiers.map(t => {
                            if (t.id === targetTierId) {
                                let newItemsInTier = [...t.items];
                                const idx = beforeItemId ? newItemsInTier.indexOf(beforeItemId) : -1;
                                if (idx !== -1) newItemsInTier.splice(idx, 0, itemId); else newItemsInTier.push(itemId);
                                return { ...t, items: newItemsInTier };
                            } return t;
                        });
                    } return newTiers;
                });
            }, [tiers, itemPoolTitle]);

            const cleanupDragStates = () => { setDraggedItemId(null); setDraggedTierId(null); setDraggedOverItemId(null); setDraggedOverTierRowId(null); setDraggedOverTierAreaId(null); };
            const handleItemDragStart = (e, itemId) => { setDraggedItemId(itemId); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', itemId); };
            const handleItemDragEnter = (e, targetItemId, targetItemTierId) => { e.preventDefault(); e.stopPropagation(); if (draggedItemId && draggedItemId !== targetItemId) { setDraggedOverItemId(targetItemId); setDraggedOverTierAreaId(targetItemTierId); } };
            const handleItemDragOver = (e, targetItemId, targetItemTierId) => { e.preventDefault(); e.stopPropagation(); e.dataTransfer.dropEffect = 'move'; if (draggedItemId && draggedItemId !== targetItemId) { setDraggedOverItemId(targetItemId); setDraggedOverTierAreaId(targetItemTierId); } };
            const handleItemDragLeave = (e, itemId) => { e.stopPropagation(); if (!e.currentTarget.contains(e.relatedTarget)) { setDraggedOverItemId(null); } };
            const handleTierAreaDragEnter = (e, tierIdContext) => { e.preventDefault(); e.stopPropagation(); if (draggedItemId) { setDraggedOverTierAreaId(tierIdContext); setDraggedOverItemId(null); } };
            const handleTierAreaDragOver = (e, tierIdContext) => { e.preventDefault(); e.stopPropagation(); if (draggedItemId) { e.dataTransfer.dropEffect = 'move'; setDraggedOverTierAreaId(tierIdContext); setDraggedOverItemId(null); } };
            const handleTierAreaDragLeave = (e, tierIdContext) => { e.stopPropagation(); if (!e.currentTarget.contains(e.relatedTarget) && draggedItemId) { setDraggedOverTierAreaId(null); } };
            const handleTierLabelDragStart = (e, tierId) => { setDraggedTierId(tierId); e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', tierId); };
            const handleTierRowDragOver = (e, targetTierId) => { e.preventDefault(); if (draggedItemId) { e.dataTransfer.dropEffect = 'move'; } else if (draggedTierId && draggedTierId !== targetTierId) { e.dataTransfer.dropEffect = 'move'; setDraggedOverTierRowId(targetTierId); } };
            const handleTierRowDragLeave = (e, tierId) => { if (!e.currentTarget.contains(e.relatedTarget) && draggedTierId) { setDraggedOverTierRowId(null); } };
            
            const handleItemDrop = (e, targetTierId, beforeItemId = null) => {
                e.preventDefault(); e.stopPropagation();
                const droppedItemId = draggedItemId || e.dataTransfer.getData('text/plain');
                if (!droppedItemId || draggedTierId) { cleanupDragStates(); return; }
                moveItem(droppedItemId, targetTierId, beforeItemId);
                cleanupDragStates();
            };

            const handleTierDrop = (e, targetTierId) => {
                e.preventDefault();
                const dTierId = draggedTierId || e.dataTransfer.getData('text/plain');
                if (!dTierId || dTierId === targetTierId || draggedItemId) { cleanupDragStates(); return; }
                setTiers(prev => {
                    const dTier = prev.find(t => t.id === dTierId); if (!dTier) return prev;
                    const remaining = prev.filter(t => t.id !== dTierId);
                    const targetIdx = remaining.findIndex(t => t.id === targetTierId);
                    if (targetIdx !== -1) remaining.splice(targetIdx, 0, dTier); else remaining.push(dTier);
                    return remaining;
                });
                cleanupDragStates();
            };

            const handleItemClick = useCallback((itemId) => {
                setSelectedItemId(prevSelectedId => {
                    if (prevSelectedId === itemId) {
                        addLog(`Item deselected. Entering Navigation Mode.`, 'event');
                        return null;
                    } else {
                        const item = items.find(i => i.id === itemId);
                        if (item) {
                            addLog(`Item selected. Entering Move Mode.`, 'event');
                            setAnnouncement(`Item ${item.value || 'image'} selected. Use arrow keys to move, or Escape to deselect.`);
                            return itemId;
                        }
                        return prevSelectedId;
                    }
                });
            }, [items, addLog]);

            const handleTierClick = useCallback((tierId) => {
                setSelectedTierId(prevSelectedId => {
                    if (prevSelectedId === tierId) {
                        addLog(`Tier deselected. Entering Navigation Mode.`, 'event');
                        setAnnouncement(`Tier deselected.`);
                        return null;
                    } else {
                        const tier = tiers.find(t => t.id === tierId);
                        if (tier) {
                            addLog(`Tier selected. Entering Move Mode.`, 'event');
                            setAnnouncement(`Tier ${tier.value} selected. Use arrow keys to reorder, or Escape to deselect.`);
                            return tierId;
                        }
                        return prevSelectedId;
                    }
                });
            }, [tiers, addLog]);

            const handleSelectNextItemInPool = useCallback(() => {
                const unassignedItems = items.filter(item => item.tierId === null);
                if (unassignedItems.length === 0) {
                    addLog("No items in the pool to select.", "info");
                    return;
                }
                const currentSelectedIndexInPool = unassignedItems.findIndex(item => item.id === selectedItemId);
                let nextItem;
                if (currentSelectedIndexInPool !== -1 && currentSelectedIndexInPool < unassignedItems.length - 1) {
                    nextItem = unassignedItems[currentSelectedIndexInPool + 1];
                } else {
                    nextItem = unassignedItems[0];
                }
                if (nextItem) {
                    handleItemClick(nextItem.id);
                    lastManuallySelectedId.current = nextItem.id;
                }
            }, [items, selectedItemId, handleItemClick, addLog]);


            useEffect(() => {
                const handleKeyDown = (e) => {
                    const activeElement = document.activeElement;
                    if (!activeElement || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    if (e.key === '/' || e.key === '?') {
                        e.preventDefault();
                        setShowCommandsPopover(prev => !prev);
                        addLog(showCommandsPopover ? 'Closed keyboard commands popover.' : 'Opened keyboard commands popover.', 'event');
                        return;
                    }

                    if (showCommandsPopover) return;

                    if (e.key.toLowerCase() === 'f') { e.preventDefault(); toggleFullScreen(); addLog('Action: Toggled fullscreen with F key', 'action'); return; }

                    if (['n', 'e'].includes(e.key.toLowerCase())) {
                        e.preventDefault();
                        handleSelectNextItemInPool();
                        return;
                    }

                    if (!activeElement.id) return;
                    const [type, id] = activeElement.id.split(/-(.+)/);
                    if (!id) return;
                    const keyMap = { 'w': 'ArrowUp', 'a': 'ArrowLeft', 's': 'ArrowDown', 'd': 'ArrowRight' };
                    const mappedKey = keyMap[e.key.toLowerCase()] || e.key;
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        addLog(`Action: Toggling selection for ${activeElement.id} with ${e.key}`, 'action');
                        if (type === 'item') handleItemClick(id); else if (type === 'tierlabel') handleTierClick(id);
                        return;
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (selectedItemId) { lastManuallySelectedId.current = selectedItemId; handleItemClick(selectedItemId); }
                        else if (selectedTierId) { lastMovedTierId.current = selectedTierId; handleTierClick(selectedTierId); }
                        return;
                    }
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(mappedKey)) {
                        e.preventDefault();
                        if (selectedItemId) {
                            addLog(`Move Mode: Arrow key ${mappedKey} for item ${selectedItemId}`, 'action');
                            const item = items.find(i => i.id === selectedItemId);
                            if (!item) return;
                            const currentTierId = item.tierId;
                            if (mappedKey === 'ArrowUp' || mappedKey === 'ArrowDown') {
                                const tierIds = [null, ...tiers.map(t => t.id)];
                                const currentTierIndex = tierIds.indexOf(currentTierId);
                                let nextTierIndex = mappedKey === 'ArrowUp' ? (currentTierIndex > 0 ? currentTierIndex - 1 : tierIds.length - 1) : (currentTierIndex < tierIds.length - 1 ? currentTierIndex + 1 : 0);
                                const nextTierId = tierIds[nextTierIndex];
                                moveItem(selectedItemId, nextTierId);
                            } else {
                                setTiers(prevTiers => prevTiers.map(tier => {
                                    if (tier.id === currentTierId) {
                                        const itemIndex = tier.items.indexOf(selectedItemId);
                                        if (itemIndex === -1) return tier;
                                        const newItems = [...tier.items];
                                        const newIndex = mappedKey === 'ArrowLeft' ? Math.max(0, itemIndex - 1) : Math.min(newItems.length - 1, itemIndex + 1);
                                        if (newIndex !== itemIndex) {
                                            [newItems[itemIndex], newItems[newIndex]] = [newItems[newIndex], newItems[itemIndex]];
                                            setAnnouncement(`Item moved ${mappedKey === 'ArrowLeft' ? 'left' : 'right'}.`);
                                            lastManuallySelectedId.current = selectedItemId;
                                        }
                                        return { ...tier, items: newItems };
                                    }
                                    return tier;
                                }));
                            }
                        } else if (selectedTierId) {
                            addLog(`Move Mode: Arrow key ${mappedKey} for tier ${selectedTierId}`, 'action');
                            if (mappedKey === 'ArrowUp' || mappedKey === 'ArrowDown') {
                                setTiers(prev => {
                                    const tierIndex = prev.findIndex(t => t.id === selectedTierId);
                                    if (tierIndex === -1) return prev;
                                    const newIndex = mappedKey === 'ArrowUp' ? Math.max(0, tierIndex - 1) : Math.min(prev.length - 1, tierIndex + 1);
                                    if (newIndex !== tierIndex) {
                                        const newTiers = [...prev];
                                        const [movedTier] = newTiers.splice(tierIndex, 1);
                                        newTiers.splice(newIndex, 0, movedTier);
                                        setAnnouncement(`Tier moved ${mappedKey === 'ArrowUp' ? 'up' : 'down'}.`);
                                        lastMovedTierId.current = selectedTierId;
                                        return newTiers;
                                    }
                                    return prev;
                                });
                            }
                        } else {
                            addLog(`Navigation Mode: Arrow key ${mappedKey} from ${activeElement.id}`, 'action');
                            handleNavigation(mappedKey, activeElement.id);
                        }
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [selectedItemId, selectedTierId, items, tiers, moveItem, handleItemClick, handleTierClick, addLog, handleSelectNextItemInPool, toggleFullScreen, showCommandsPopover]);

            const { focusableGrid, focusableMap } = useMemo(() => {
                const grid = []; const map = {};
                tiers.forEach((tier) => { const row = [`tier-label-${tier.id}`]; tier.items.forEach(itemId => { row.push(`item-${itemId}`); }); grid.push(row); });
                const unassignedItems = items.filter(item => item.tierId === null);
                if (unassignedItems.length > 0) { grid.push(unassignedItems.map(item => `item-${item.id}`)); }
                grid.forEach((row, rowIndex) => { row.forEach((id, colIndex) => { map[id] = { row: rowIndex, col: colIndex }; }); });
                return { focusableGrid: grid, focusableMap: map };
            }, [tiers, items]);

            const handleNavigation = (key, currentId) => {
                if (!focusableMap[currentId]) return;
                const { row: currentRow, col: currentCol } = focusableMap[currentId];
                let nextRow = currentRow, nextCol = currentCol;
                switch (key) {
                    case 'ArrowUp': nextRow = currentRow > 0 ? currentRow - 1 : focusableGrid.length - 1; break;
                    case 'ArrowDown': nextRow = currentRow < focusableGrid.length - 1 ? currentRow + 1 : 0; break;
                    case 'ArrowLeft': if (currentCol > 0) nextCol = currentCol - 1; break;
                    case 'ArrowRight': if (currentCol < focusableGrid[currentRow].length - 1) nextCol = currentCol + 1; break;
                    default: return;
                }
                if (key === 'ArrowUp' || key === 'ArrowDown') { nextCol = Math.min(currentCol, focusableGrid[nextRow].length - 1); }
                const nextId = focusableGrid[nextRow]?.[nextCol];
                if (nextId) { const nextElement = document.getElementById(nextId); if (nextElement) nextElement.focus(); }
            };

            useEffect(() => {
                if (lastManuallySelectedId.current) { const el = document.getElementById(`item-${lastManuallySelectedId.current}`); if (el) el.focus(); lastManuallySelectedId.current = null; }
                if (lastMovedTierId.current) { const el = document.getElementById(`tier-label-${lastMovedTierId.current}`); if (el) el.focus(); lastMovedTierId.current = null; }
            }, [items, tiers]);

             useEffect(() => { if (selectedItemId && document.activeElement?.id !== `item-${selectedItemId}`) { const el = document.getElementById(`item-${selectedItemId}`); if (el) el.focus(); } }, [selectedItemId]);

            const handleResizeMouseDown = (e) => {
                e.preventDefault();
                setIsResizing(true);
            };

            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!isResizing) return;
                    const containerRect = appContainerRef.current.getBoundingClientRect();
                    const newWidthPercent = ((e.clientX - containerRect.left) / containerRect.width) * 100;
                    // Constrain the panel width between 50% and 80% for the tier list
                    const constrainedWidth = Math.max(50, Math.min(80, newWidthPercent));
                    setTierListPanelWidth(constrainedWidth);
                };

                const handleMouseUp = () => {
                    setIsResizing(false);
                };

                if (isResizing) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                }

                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizing]);

            const theme = {
                darkMode,
                bg: darkMode ? 'bg-black' : 'bg-gray-100',
                text: darkMode ? 'text-gray-100' : 'text-gray-900',
                containerBg: darkMode ? 'bg-gray-800' : 'bg-white',
                itemBg: darkMode ? 'bg-gray-700' : 'bg-gray-50',
                inputBg: darkMode ? 'bg-gray-700' : 'bg-gray-50',
                inputText: darkMode ? 'text-gray-200' : 'text-gray-800',
                placeholderText: darkMode ? 'placeholder-gray-400' : 'placeholder-gray-500',
                borderColor: darkMode ? 'border-gray-600' : 'border-gray-300',
                buttonPrimaryBg: darkMode ? 'bg-blue-600 hover:bg-blue-700' : 'bg-blue-500 hover:bg-blue-600',
                buttonSecondaryBg: darkMode ? 'bg-gray-600 hover:bg-gray-700' : 'bg-gray-500 hover:bg-gray-600',
                buttonText: 'text-white',
                sectionBg: darkMode ? 'bg-gray-800' : 'bg-white',
            };
            const dragState = { draggedItemId, draggedTierId, draggedOverItemId, draggedOverTierRowId, draggedOverTierAreaId, selectedItemId, selectedTierId };
            const itemProps = { itemWidth, itemHeight, tierLabelWidth };
            const itemSetters = { setItemWidth, setItemHeight, setTierLabelWidth };
            const allHandlers = { handleItemDragStart, handleItemDragEnter, handleItemDragOver, handleItemDragLeave, handleItemDrop, handleTierAreaDragEnter, handleTierAreaDragOver, handleTierAreaDragLeave, handleTierLabelDragStart, handleTierRowDragOver, handleTierRowDragLeave, handleTierDrop, handleDeleteItem, handleDeleteTier, startEditingTier, cleanupDragStates, addLog, handleAddTier, handleAddItem, handlePasteItems, handleResetAllItemsToPool, handleSaveEditedTier, cancelEditingTier, handleExportState, handleImportState, handleItemImageUpload, handleExportImage, handleItemClick, handleTierClick };
            const uiState = { showConfiguration, editingTierId, showLogs };
            const uiSetters = { setShowConfiguration, setShowLogs, handleSelectFirstItemInPool };
            const data = { logs, standardColors };
            const editState = { editingTierLabel, editingTierColor, newTierColor };
            const editSetters = { setEditingTierLabel, setEditingTierColor, setNewTierColor };
            const refs = { newTierNameRef, newItemNameRef, newItemImageFileRef, newItemImageUrlRef, pasteItemsRef, importFileRef, logDisplayRef };

            const isSideLayout = poolPosition === 'right';

            return (
                <div className={`min-h-screen font-sans transition-colors duration-300 ${theme.bg} ${theme.text}`}>
                    {showCommandsPopover && <CommandsPopover theme={theme} onClose={() => setShowCommandsPopover(false)} />}
                    <div aria-live="assertive" style={{ position: 'absolute', width: '1px', height: '1px', padding: '0', margin: '-1px', overflow: 'hidden', clip: 'rect(0, 0, 0, 0)', whiteSpace: 'nowrap', border: '0' }}>{announcement}</div>

                    <div ref={appContainerRef} className="mx-auto max-w-full flex flex-col gap-1 p-1">
                        <div className={`relative ${theme.containerBg}`}>
                             <button
                                onClick={() => setShowCommandsPopover(true)}
                                className={`absolute top-4 right-4 p-2 rounded-full z-20 ${theme.darkMode ? 'text-gray-400 hover:bg-gray-700 hover:text-white' : 'text-gray-500 hover:bg-gray-200 hover:text-black'}`}
                                aria-label="Show keyboard commands"
                            >
                                <HelpCircleIcon size={28} />
                            </button>
                            <input type="text" value={tierListTitle} onChange={(e) => setTierListTitle(e.target.value)} className={`text-3xl sm:text-4xl font-extrabold bg-transparent border-none focus:outline-none focus:ring-0 text-center w-full p-4 ${theme.text}`} aria-label="Tier list title"/>
                        </div>

                        <div className={`flex ${isSideLayout ? 'flex-row' : 'flex-col gap-1'}`}>
                            <div
                                className="tier-list-container"
                                style={isSideLayout ? { width: `${tierListPanelWidth}%` } : { width: '100%' }}
                            >
                                <div ref={tierListRef} className="w-full flex flex-col gap-1">
                                    {tiers.map((tier, index) => (
                                        <TierRow key={tier.id} tier={tier} items={items} theme={theme} dragState={dragState} handlers={allHandlers} itemProps={itemProps} index={index} totalTiers={tiers.length} deleteMode={deleteMode} selectedTierId={selectedTierId} />
                                    ))}
                                </div>
                                {!isSideLayout && (
                                    <div>
                                        <ItemPool items={items} itemPoolTitle={itemPoolTitle} setItemPoolTitle={setItemPoolTitle} theme={theme} dragState={dragState} handlers={allHandlers} itemProps={itemProps} deleteMode={deleteMode} poolPosition={poolPosition} onTogglePosition={handleTogglePosition} />
                                    </div>
                                )}
                            </div>

                            {isSideLayout && (
                                <>
                                    <div onMouseDown={handleResizeMouseDown} className={`w-1 cursor-col-resize flex-shrink-0 ${theme.bg} hover:bg-blue-500/50 transition-colors`}></div>
                                    <div
                                        className="item-pool-container flex-grow"
                                        style={{ width: `${100 - tierListPanelWidth}%` }}
                                    >
                                        <ItemPool items={items} itemPoolTitle={itemPoolTitle} setItemPoolTitle={setItemPoolTitle} theme={theme} dragState={dragState} handlers={allHandlers} itemProps={itemProps} deleteMode={deleteMode} poolPosition={poolPosition} onTogglePosition={handleTogglePosition} />
                                    </div>
                                </>
                            )}
                        </div>

                        <ConfigurationPanel theme={theme} uiState={uiState} uiSetters={uiSetters} data={data} dataHandlers={allHandlers} editState={editState} editSetters={editSetters} refs={refs} itemProps={itemProps} itemSetters={itemSetters} deleteMode={deleteMode} setDeleteMode={setDeleteMode} setContainerWidth={() => {}} toggleFullScreen={toggleFullScreen} setDarkMode={setDarkMode} isFullscreen={isFullscreen} darkMode={darkMode} />
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
