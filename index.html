<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tier List Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Library to render DOM elements to a canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
            /* Disable text selection and callout menu on touch */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none; /* Standard syntax */
            -webkit-touch-callout: none; /* iOS Safari */
        }
        /* Custom styles for color input */
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.125rem; }
        input[type="color"] { -webkit-appearance: none; width: 2.5rem; height: 2.5rem; border: none; background: none; cursor: pointer; border-radius: 0.125rem; }
        
        /* Drag and Drop Visual Feedback */
        .drag-over-item { outline: 3px dashed #60A5FA !important; outline-offset: 2px; z-index: 10; }
        .drag-over-tier-area { background-color: rgba(79, 70, 229, 0.1) !important; }
        
        /* Tier Label Dragging Styles */
        .tier-label-draggable { cursor: grab !important; }
        .tier-label-dragging { opacity: 0.5; }
        .tier-row-drop-target { border-top: 3px dashed #4F46E5 !important; border-bottom: 3px dashed #4F46E5 !important; }
        
        /* Resize Handle Styles */
        .resize-handle-x { position: absolute; right: -5px; top: 0; width: 10px; height: 100%; cursor: col-resize; z-index: 50; }
        .resize-handle-x-visual { width: 4px; height: 100%; background-color: #4B5563; border-radius: 2px; position: absolute; right: 3px; }
        .dark .resize-handle-x-visual { background-color: #6B7280; }

        .resize-handle-y { position: absolute; left: 0; top: -5px; width: 100%; height: 10px; cursor: row-resize; z-index: 50; }
        .resize-handle-y-visual { width: 100%; height: 4px; background-color: #4B5563; border-radius: 2px; position: absolute; top: 3px; }
        .dark .resize-handle-y-visual { background-color: #6B7280; }


        /* Toggle Switch Styles */
        .toggle-checkbox:checked { right: 0; border-color: #4F46E5; }
        .toggle-checkbox:checked + .toggle-label { background-color: #4F46E5; }

        /* Accessibility & Mobile Selection Styles */
        *:focus-visible {
            outline: 3px solid #60A5FA;
            outline-offset: 2px;
            border-radius: 2px;
        }
        .keyboard-selected {
            outline: 3px solid #4F46E5 !important;
            outline-offset: 2px;
            border-radius: 2px;
            box-shadow: 0 0 10px #4F46E5;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo, memo } = React;

        // --- ICONS ---
        const PlusCircleIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 8v8"/><path d="M8 12h8"/></svg>;
        const ListIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>;
        const Trash2Icon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"/><path d="M19 6v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V6"/><path d="M8 6V4c0-1.1.9-2 2-2h4c1.1 0 2 .9 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
        const SunIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M4.93 19.07l1.41-1.41"/><path d="M17.66 6.34l1.41-1.41"/></svg>;
        const MoonIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>;
        const PencilIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>;
        const ChevronUpIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m18 15-6-6-6 6"/></svg>;
        const ChevronDownIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m6 9 6 6 6-6"/></svg>;
        const SettingsIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const FileTextIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>;
        const RotateCcwIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>;
        const MaximizeIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>;
        const MinimizeIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>;
        const DownloadIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const UploadIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const XIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;
        const ImageIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>;
        const HelpCircleIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>;
        const ArrowDownToLineIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/></svg>;
        const ArrowRightToLineIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M17 12H3"/><path d="m11 18 6-6-6-6"/><path d="M21 5v14"/></svg>;
        const ZoomInIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>;
        const ZoomOutIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>;
        const FilePlusIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M9 15h6"/><path d="M12 12v6"/></svg>;
        const AlertTriangleIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/></svg>;
        const FolderOpenIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2"/></svg>;
        const DownloadCloudIcon = ({ size = 24, className = '' }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m8 17 4 4 4-4"/></svg>;


        // --- STATE VALIDATION & SERIALIZATION ---
        const validateStateData = (parsedData) => {
            if (parsedData && typeof parsedData === 'object' && !Array.isArray(parsedData)) {
                const validatedData = {
                    ...parsedData,
                    tiers: Array.isArray(parsedData.tiers) ? parsedData.tiers.map(tier => ({ ...tier, items: Array.isArray(tier.items) ? tier.items : [] })) : undefined,
                    items: Array.isArray(parsedData.items) ? parsedData.items : undefined,
                    itemWidth: parsedData.itemWidth || 80,
                    itemHeight: parsedData.itemHeight || 80,
                    containerWidth: parsedData.containerWidth || window.innerWidth,
                    itemPoolTitle: parsedData.itemPoolTitle || "Item Pool",
                    tierLabelWidth: parsedData.tierLabelWidth || 128,
                    tierListTitle: parsedData.tierListTitle || "My Tier List"
                };

                if (validatedData.tiers && validatedData.items) {
                    const validItemIds = new Set(validatedData.items.map(i => i.id));
                    validatedData.tiers = validatedData.tiers.map(tier => ({ ...tier, items: tier.items.filter(id => validItemIds.has(id)) }));
                    const validTierIds = new Set(validatedData.tiers.map(t => t.id));
                    validatedData.items = validatedData.items.map(item => ({ ...item, tierId: validTierIds.has(item.tierId) ? item.tierId : null }));
                }

                return { data: validatedData, error: null };
            }
            return { data: null, error: { message: "Invalid state structure.", type: "warning" } };
        };

        const serializeStateForURL = (stateData) => {
            try {
                // Create a deep copy to avoid modifying the original state
                const stateToSerialize = JSON.parse(JSON.stringify(stateData));
                // Filter out items with base64 image data
                stateToSerialize.items = stateToSerialize.items.filter(item => !item.value.startsWith('data:image'));
                return encodeURIComponent(JSON.stringify(stateToSerialize));
            } catch (error) {
                console.error("Error serializing state for URL:", error);
                return "";
            }
        };

        const deserializeState = (encodedString) => {
            if (!encodedString) return { data: null, error: null };
            try {
                const parsedData = JSON.parse(decodeURIComponent(encodedString));
                return validateStateData(parsedData);
            } catch (e) {
                return { data: null, error: { message: `Error parsing state: ${e.message}`, type: "error" } };
            }
        };

        // --- UI COMPONENTS ---

        const DragPreview = ({ item, itemWidth, itemHeight, position, theme }) => {
            if (!item || !position) return null;
            const style = {
                position: 'fixed',
                pointerEvents: 'none',
                zIndex: 1000,
                left: 0,
                top: 0,
                width: `${itemWidth}px`,
                height: `${itemHeight}px`,
                transform: `translate(${position.x}px, ${position.y}px)`,
                opacity: 0.8,
            };
            return (
                <div style={style}>
                    <div className={`w-full h-full flex items-center justify-center overflow-hidden ${theme.itemBg} border ${theme.borderColor} rounded-sm shadow-lg`}>
                        {item.type === 'image' ? (
                            <img src={item.value} alt={item.value || "Item"} className="w-full h-full object-contain" />
                        ) : (
                            <span className={`text-sm font-medium ${theme.inputText} text-center p-1 break-all`}>{item.value}</span>
                        )}
                    </div>
                </div>
            );
        };

        const DraggableItem = memo(({ item, itemWidth, itemHeight, theme, draggedItemId, draggedOverItemId, handlers, deleteMode, selectedItemId }) => (
            <div
                id={`item-${item.id}`}
                tabIndex={0}
                role="button"
                aria-pressed={selectedItemId === item.id}
                aria-label={`Item: ${item.value || 'image'}. ${item.tierId ? `In tier ${item.tierId}` : 'In item pool'}. Press Space or Enter to select.`}
                draggable={true}
                onClick={() => handlers.handleItemClick(item.id)}
                onDragStart={(e) => handlers.handleItemDragStart(e, item.id)}
                onDragEnter={(e) => handlers.handleItemDragEnter(e, item.id, item.tierId)}
                onDragOver={(e) => handlers.handleDragOver(e)}
                onDragLeave={(e) => handlers.handleItemDragLeave(e)}
                onDrop={(e) => handlers.handleDrop(e, item.tierId, item.id)}
                onDragEnd={handlers.cleanupDragStates}
                onTouchStart={(e) => handlers.handleTouchStart(e, item)}
                className={`relative z-10 cursor-grab active:cursor-grabbing
                                ${draggedItemId === item.id ? 'opacity-30' : ''}
                                ${selectedItemId === item.id ? 'keyboard-selected' : ''}`}
                style={{ width: `${itemWidth}px`, height: `${itemHeight}px` }}
            >
                <div
                    className={`w-full h-full flex items-center justify-center overflow-hidden ${theme.itemBg} border ${theme.borderColor} rounded-sm shadow-sm transition-all duration-200
                    ${draggedItemId === item.id ? 'ring-2 ring-indigo-500' : ''}
                    ${draggedOverItemId === item.id && draggedItemId !== item.id ? 'drag-over-item' : ''}`}
                >
                    {item.type === 'image' ? (
                        <img src={item.value} alt={item.value || "Item"} className="w-full h-full object-contain pointer-events-none" crossOrigin="anonymous" onError={(e) => { e.target.onerror = null; e.target.src = `https://placehold.co/${itemWidth}x${itemHeight}/FF0000/FFFFFF?text=Error`; e.target.alt = "Image failed"; }} />
                    ) : (
                        <span className={`text-sm font-medium ${theme.inputText} text-center p-1 break-all pointer-events-none`}>{item.value}</span>
                    )}
                </div>
                <button
                    onClick={(e) => { e.stopPropagation(); handlers.handleDeleteItem(item.id); }}
                    className={`absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-1 z-20 transition-opacity ${deleteMode ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
                    aria-label={`Delete item ${item.value}`}
                >
                    <Trash2Icon size={14} />
                </button>
            </div>
        ));

        const TierRow = ({ tier, items, theme, dragState, handlers, itemProps, deleteMode, selectedTierId }) => {
            const { draggedTierId, draggedOverTierRowId, draggedOverTierAreaId, draggedItemId, draggedOverItemId, selectedItemId } = dragState;
            const tierItems = tier.items.map(itemId => items.find(i => i.id === itemId)).filter(Boolean);
            const minTierHeight = itemProps.itemHeight + 16; // itemHeight + p-2 (8px top + 8px bottom)

            return (
                <div
                    onDragOver={(e) => handlers.handleTierRowDragOver(e, tier.id)}
                    onDragLeave={(e) => handlers.handleTierRowDragLeave(e)}
                    onDrop={(e) => handlers.handleDrop(e, tier.id)}
                    className={`flex items-stretch transition-all duration-200
                                ${draggedOverTierRowId === tier.id && draggedTierId && draggedTierId !== tier.id ? 'tier-row-drop-target' : ''}`}
                    style={{ minHeight: `${minTierHeight}px` }}
                >
                    <div
                        id={`tier-label-${tier.id}`}
                        tabIndex={0}
                        role="button"
                        aria-pressed={selectedTierId === tier.id}
                        aria-label={`Tier: ${tier.value}. Press Space or Enter to select.`}
                        draggable={true}
                        onClick={() => handlers.handleTierClick(tier.id)}
                        onDragStart={(e) => handlers.handleTierLabelDragStart(e, tier.id)}
                        onDragEnd={handlers.cleanupDragStates}
                        className={`relative flex-shrink-0 p-3 flex items-center justify-center text-center font-bold text-lg text-black group tier-label-draggable ${draggedTierId === tier.id ? 'tier-label-dragging' : ''} ${selectedTierId === tier.id ? 'keyboard-selected' : ''}`}
                        style={{ backgroundColor: tier.color, width: `${itemProps.tierLabelWidth}px` }}
                    >
                        <span className="pointer-events-none">{tier.value}</span>
                        <>
                            <button onClick={(e) => { e.stopPropagation(); handlers.handleDeleteTier(tier.id); }} className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 z-10" aria-label={`Delete tier ${tier.value}`}> <Trash2Icon size={14} /> </button>
                            <button onClick={(e) => { e.stopPropagation(); handlers.startEditingTier(tier); }} className="absolute top-1 left-1 bg-gray-600 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 z-10" aria-label={`Edit tier ${tier.value}`}> <PencilIcon size={14} /> </button>
                        </>
                    </div>
                    <div
                        data-droptarget-tier-id={tier.id}
                        onDragEnter={(e) => handlers.handleTierAreaDragEnter(e, tier.id)}
                        onDragOver={(e) => handlers.handleDragOver(e)}
                        onDragLeave={(e) => handlers.handleTierAreaDragLeave(e)}
                        onDrop={(e) => handlers.handleDrop(e, tier.id, null)}
                        className={`flex-grow p-2 flex flex-wrap gap-2 items-start justify-start ${theme.containerBg}
                                ${draggedOverTierAreaId === tier.id && draggedItemId && !draggedOverItemId ? 'drag-over-tier-area' : ''}`}
                        aria-label={`Tier ${tier.value} content area`}
                    >
                        {tierItems.map(item => <DraggableItem key={item.id} item={item} {...itemProps} theme={theme} deleteMode={deleteMode} draggedItemId={draggedItemId} draggedOverItemId={draggedOverItemId} handlers={handlers} selectedItemId={selectedItemId} />)}
                    </div>
                </div>
            );
        };

        const ItemPool = ({ items, itemPoolTitle, setItemPoolTitle, theme, dragState, handlers, itemProps, deleteMode, poolPosition, onTogglePosition }) => {
            const { draggedOverTierAreaId, draggedItemId, draggedOverItemId, selectedItemId } = dragState;
            const unassignedItems = items.filter(item => item.tierId === null);
            const isSideLayout = poolPosition === 'right';

            return (
                <div
                    data-droptarget-tier-id="null"
                    onDragEnter={(e) => handlers.handleTierAreaDragEnter(e, null)}
                    onDragOver={(e) => handlers.handleDragOver(e)}
                    onDragLeave={(e) => handlers.handleTierAreaDragLeave(e)}
                    onDrop={(e) => handlers.handleDrop(e, null, null)}
                    className={`relative p-4 flex flex-col ${theme.containerBg}
                                ${draggedOverTierAreaId === null && draggedItemId ? 'drag-over-tier-area' : ''}
                                ${isSideLayout ? 'h-full' : 'min-h-[150px] w-full'}`}
                    aria-label="Item Pool area"
                >
                    <div className={`text-xl font-semibold ${theme.text} mb-3 flex items-center justify-center gap-2`}>
                        <input
                            type="text"
                            value={itemPoolTitle}
                            onChange={(e) => setItemPoolTitle(e.target.value)}
                            className={`bg-transparent border-none focus:outline-none focus:ring-0 text-center p-0 font-semibold ${theme.text}`}
                            aria-label="Item pool title"
                        />
                    </div>
                    <div className={`flex flex-wrap gap-2 justify-center sm:justify-start flex-grow ${isSideLayout ? 'overflow-y-auto p-2' : 'min-h-[100px]'}`}>
                        {unassignedItems.map(item => <DraggableItem key={item.id} item={item} {...itemProps} theme={theme} deleteMode={deleteMode} draggedItemId={draggedItemId} draggedOverItemId={draggedOverItemId} handlers={handlers} selectedItemId={selectedItemId} />)}
                    </div>
                    <div className="absolute bottom-4 right-4 flex gap-2">
                        { window.innerWidth >= 1280 &&
                            <button onClick={onTogglePosition} className={`w-12 h-12 rounded-full shadow-lg flex items-center justify-center ${theme.darkMode ? 'bg-gray-600 hover:bg-gray-700' : 'bg-gray-400 hover:bg-gray-500'} ${theme.buttonText}`} aria-label={isSideLayout ? "Move item pool to bottom" : "Move item pool to right"}>
                                {isSideLayout ? <ArrowDownToLineIcon size={24} /> : <ArrowRightToLineIcon size={24} />}
                            </button>
                        }
                        <button onClick={handlers.handleResetAllItemsToPool} className={`w-12 h-12 rounded-full shadow-lg flex items-center justify-center ${theme.darkMode ? 'bg-red-700 hover:bg-red-800' : 'bg-red-500 hover:bg-red-600'} ${theme.buttonText}`} aria-label="Reset all items to pool"><RotateCcwIcon size={24}/></button>
                    </div>
                </div>
            );
        };
        
        const CommandsPopover = ({ theme, onClose }) => {
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        onClose();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [onClose]);

            const commands = [
                { keys: ['/', '?'], desc: 'Toggle this help menu' },
                { keys: ['Space', 'Enter'], desc: 'Select / Deselect an item or tier' },
                { keys: ['Esc'], desc: 'Deselect current item or tier' },
                { keys: ['W', '↑'], desc: 'Navigate up / Move item up a tier / Move tier up' },
                { keys: ['A', '←'], desc: 'Navigate left / Move item left within tier' },
                { keys: ['S', '↓'], desc: 'Navigate down / Move item down a tier / Move tier down' },
                { keys: ['D', '→'], desc: 'Navigate right / Move item right within tier' },
                { keys: ['N', 'E'], desc: 'Select next item in Item Pool' },
                { keys: ['F'], desc: 'Toggle fullscreen mode' },
            ];

            return (
                <div 
                    className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50" 
                    onClick={onClose} 
                    role="dialog" 
                    aria-modal="true" 
                    aria-labelledby="commands-title"
                >
                    <div 
                        className={`relative w-full max-w-lg p-6 rounded-sm shadow-xl ${theme.containerBg}`}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <button 
                            onClick={onClose} 
                            className={`absolute top-4 right-4 p-2 rounded-full ${theme.darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-200'}`} 
                            aria-label="Close keyboard commands"
                        >
                            <XIcon size={24} className={theme.text} />
                        </button>
                        <h2 id="commands-title" className={`text-2xl font-bold mb-4 ${theme.text}`}>Keyboard Commands ⌨️</h2>
                        <div className="space-y-3">
                            {commands.map((cmd, i) => (
                                <div key={i} className={`flex justify-between items-center p-2 rounded ${theme.sectionBg}`}>
                                    <span className={`font-mono text-sm ${theme.inputText}`}>
                                        {cmd.keys.map(key => (
                                            <kbd key={key} className={`px-2 py-1 mr-1 rounded-md border ${theme.borderColor} ${theme.darkMode ? 'bg-gray-900' : 'bg-gray-100'}`}>
                                                {key}
                                            </kbd>
                                        ))}
                                    </span>
                                    <span className={`text-sm ${theme.text}`}>{cmd.desc}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const ConfirmationModal = ({ theme, onConfirm, onCancel, title, message }) => {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50" role="dialog" aria-modal="true" aria-labelledby="modal-title">
                    <div className={`relative w-full max-w-md p-6 rounded-sm shadow-xl ${theme.containerBg}`}>
                        <h2 id="modal-title" className={`text-2xl font-bold mb-4 ${theme.text} flex items-center`}><AlertTriangleIcon size={24} className="mr-2 text-yellow-400"/>{title}</h2>
                        <p className={`mb-6 ${theme.inputText}`}>{message}</p>
                        <div className="flex justify-end gap-4">
                            <button onClick={onCancel} className={`px-4 py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText}`}>Cancel</button>
                            <button onClick={onConfirm} className={`px-4 py-2 rounded-sm shadow-sm bg-red-600 hover:bg-red-700 text-white`}>Confirm</button>
                        </div>
                    </div>
                </div>
            );
        };

        const OpenTierListModal = ({ theme, onClose, addLog }) => {
            const [savedLists, setSavedLists] = useState([]);

            useEffect(() => {
                const lists = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('tierListMakerState_')) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            const id = key.replace('tierListMakerState_', '');
                            lists.push({ id, title: data.tierListTitle || 'Untitled Tier List' });
                        } catch (e) {
                            console.error(`Could not parse saved tier list: ${key}`, e);
                        }
                    }
                }
                setSavedLists(lists);
            }, []);

            const handleDelete = (idToDelete) => {
                localStorage.removeItem(`tierListMakerState_${idToDelete}`);
                setSavedLists(prev => prev.filter(list => list.id !== idToDelete));
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50" role="dialog" aria-modal="true" aria-labelledby="open-modal-title">
                    <div className={`relative w-full max-w-lg p-6 rounded-sm shadow-xl ${theme.containerBg}`} onClick={(e) => e.stopPropagation()}>
                        <button onClick={onClose} className={`absolute top-4 right-4 p-2 rounded-full ${theme.darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-200'}`} aria-label="Close">
                            <XIcon size={24} className={theme.text} />
                        </button>
                        <h2 id="open-modal-title" className={`text-2xl font-bold mb-4 ${theme.text}`}>Open Saved Tier List</h2>
                        <div className="space-y-2 max-h-96 overflow-y-auto">
                            {savedLists.length > 0 ? savedLists.map(list => (
                                <div key={list.id} className={`flex justify-between items-center p-3 rounded ${theme.sectionBg} border ${theme.borderColor}`}>
                                    <a href={`${window.location.pathname}?id=${list.id}`} target="_blank" rel="noopener noreferrer" className={`font-medium hover:underline ${theme.darkMode ? 'text-blue-400' : 'text-blue-600'}`}>
                                        {list.title}
                                    </a>
                                    <button onClick={() => handleDelete(list.id)} className="p-1 text-red-500 hover:text-red-700 rounded-full" aria-label={`Delete ${list.title}`}>
                                        <Trash2Icon size={18} />
                                    </button>
                                </div>
                            )) : (
                                <p className={theme.inputText}>No saved tier lists found.</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };


        const ConfigurationPanel = ({ theme, uiState, uiSetters, data, dataHandlers, editState, editSetters, refs, itemProps, itemSetters, deleteMode, setDeleteMode, setContainerWidth, toggleFullScreen, setDarkMode, isFullscreen, darkMode }) => {
            const { showConfiguration, editingTierId } = uiState;
            const { setShowConfiguration, handleSelectFirstItemInPool } = uiSetters;
            const { standardColors } = data;
            const { handleAddTier, handleAddItem, handlePasteItems, handleSaveEditedTier, cancelEditingTier, handleExportImage, handleClearAllData, handleNewTierList, handleOpenTierList } = dataHandlers;
            const { editingTierLabel, editingTierColor, newTierColor } = editState;
            const { setEditingTierLabel, setEditingTierColor, setNewTierColor } = editSetters;
            const { newTierNameRef, newItemNameRef, newItemImageFileRef, newItemImageUrlRef, pasteItemsRef, importFileRef } = refs;
            const { itemWidth, itemHeight, tierLabelWidth } = itemProps;
            const { setItemWidth, setItemHeight, setTierLabelWidth } = itemSetters;

            const handleHexColorChange = (e, isEditing) => {
                const hex = e.target.value;
                if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {
                    if (isEditing) setEditingTierColor(hex); else setNewTierColor(hex);
                }
            };

            const handleConfigToggle = () => {
                if (showConfiguration) { // If it's currently open and about to close
                    handleSelectFirstItemInPool();
                    window.scrollTo(0, 0);
                }
                setShowConfiguration(!showConfiguration);
            }

            const zoomPresets = [
                { name: 'XS', w: 40, h: 40, lw: 96 },
                { name: 'S', w: 60, h: 60, lw: 112 },
                { name: 'M', w: 80, h: 80, lw: 128 },
                { name: 'L', w: 100, h: 100, lw: 144 },
                { name: 'XL', w: 120, h: 120, lw: 160 },
                { name: '2XL', w: 140, h: 140, lw: 192 },
                { name: '3XL', w: 160, h: 160, lw: 224 },
            ];

            const handleZoomPreset = (preset) => {
                setItemWidth(preset.w);
                setItemHeight(preset.h);
                setTierLabelWidth(preset.lw);
            };

            const handleZoomAdjust = (factor) => {
                setItemWidth(w => Math.round(Math.max(20, w * factor)));
                setItemHeight(h => Math.round(Math.max(20, h * factor)));
                setTierLabelWidth(lw => Math.round(Math.max(40, lw * factor)));
            };

            return (
                <div className="flex flex-col gap-1">
                    <div className={`${theme.containerBg} p-4`}>
                        <h2 className={`text-2xl font-bold ${theme.text} mb-4 text-center flex items-center justify-center gap-2`}>
                            <SettingsIcon size={24} /> Configuration
                            <button onClick={handleConfigToggle} className={`p-1 rounded-full ${theme.darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-300 hover:bg-gray-400'}`} aria-expanded={showConfiguration}> {showConfiguration ? <ChevronUpIcon size={20} /> : <ChevronDownIcon size={20} />} </button>
                        </h2>
                    </div>
                        {showConfiguration && (
                            <div className="flex flex-col gap-1">
                                {/* General Settings */}
                                <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                    <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-purple-300':'text-purple-600'} mb-3 flex items-center gap-2`}> <SettingsIcon size={20}/> General Settings</h3>
                                    <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-4">
                                        <button onClick={() => setContainerWidth(window.innerWidth)} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}>
                                            Fit to Screen
                                        </button>
                                        <button onClick={toggleFullScreen} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}>
                                            {isFullscreen ? <MinimizeIcon size={20} /> : <MaximizeIcon size={20} />}
                                            {isFullscreen ? "Exit" : "Fullscreen"}
                                        </button>
                                        <button onClick={() => setDarkMode(!darkMode)} className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}>
                                            {darkMode ? <SunIcon size={20} /> : <MoonIcon size={20} />}
                                            {darkMode ? "Light" : "Dark"}
                                        </button>
                                        <button
                                            onClick={handleExportImage}
                                            className={`w-full py-2 rounded-sm shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText} flex items-center justify-center gap-2`}
                                        >
                                            <ImageIcon size={20} /> Export Image
                                        </button>
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 lg:grid-cols-3 gap-1">
                                    {/* Edit/Create Tier */}
                                    {editingTierId ? (
                                        <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                            <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-indigo-300':'text-indigo-600'} mb-2 flex items-center gap-2`}> <PencilIcon size={20}/> Edit Tier</h3>
                                            <input type="text" value={editingTierLabel} onChange={e=>setEditingTierLabel(e.target.value)} placeholder="Label" className={`w-full p-2 mb-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <div className="flex items-center gap-2 mb-2"> {standardColors.map(c=><button key={c} onClick={()=>setEditingTierColor(c)} className={`w-7 h-7 rounded-full border-2 ${editingTierColor===c?(theme.darkMode?'border-white':'border-black'):'border-transparent'}`} style={{backgroundColor:c}} aria-label={`Set color to ${c}`}/>)} </div>
                                            <div className="flex items-center gap-2 mb-3">
                                                <input type="color" value={editingTierColor} onChange={e=>setEditingTierColor(e.target.value)} className={`w-9 h-9 rounded-sm ${theme.darkMode?'border-gray-600':'border-gray-400'} border`} aria-label="Custom color picker"/>
                                                <input type="text" value={editingTierColor} onChange={e=>handleHexColorChange(e,true)} placeholder="#hex" className={`p-2 w-28 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`} aria-label="Hex color value"/>
                                            </div>
                                            <div className="flex gap-2"><button onClick={handleSaveEditedTier} className={`flex-1 py-2 ${theme.darkMode?'bg-indigo-600 hover:bg-indigo-700':'bg-indigo-500 hover:bg-indigo-600'} ${theme.buttonText} rounded-sm`}>Save</button> <button onClick={cancelEditingTier} className={`flex-1 py-2 ${theme.buttonSecondaryBg} ${theme.buttonText} rounded-sm`}>Cancel</button></div>
                                        </div>
                                    ) : (
                                        <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                            <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-blue-300':'text-blue-600'} mb-2 flex items-center gap-2`}> <PlusCircleIcon size={20}/> Create Tier</h3>
                                            <input type="text" ref={newTierNameRef} placeholder="Label" className={`w-full p-2 mb-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <div className="flex items-center gap-2 mb-2"> {standardColors.map(c=><button key={c} onClick={()=>setNewTierColor(c)} className={`w-7 h-7 rounded-full border-2 ${newTierColor===c?(theme.darkMode?'border-white':'border-black'):'border-transparent'}`} style={{backgroundColor:c}} aria-label={`Set color to ${c}`}/>)} </div>
                                            <div className="flex items-center gap-2 mb-3">
                                                <input type="color" value={newTierColor} onChange={e=>setNewTierColor(e.target.value)} className={`w-9 h-9 rounded-sm ${theme.darkMode?'border-gray-600':'border-gray-400'} border`} aria-label="Custom color picker"/>
                                                <input type="text" value={newTierColor} onChange={e=>handleHexColorChange(e,false)} placeholder="#hex" className={`p-2 w-28 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`} aria-label="Hex color value"/>
                                            </div>
                                            <button onClick={handleAddTier} className={`w-full py-2 ${theme.buttonPrimaryBg} ${theme.buttonText} rounded-sm`}>Add Tier</button>
                                        </div>
                                    )}
                                    {/* Add Item */}
                                    <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                        <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-green-300':'text-green-600'} mb-3 flex items-center gap-2`}> <PlusCircleIcon size={20}/> Add Item</h3>
                                        <div className="flex flex-col gap-3">
                                            <input type="text" ref={newItemNameRef} placeholder="Name" className={`w-full p-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <input type="text" ref={newItemImageUrlRef} placeholder="Image URL" className={`w-full p-2 border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                            <div className="flex flex-col gap-2 pt-1">
                                                <label className={`w-full py-2 px-4 text-center rounded-sm cursor-pointer ${theme.darkMode?'bg-green-600/80 hover:bg-green-700/80':'bg-green-500/80 hover:bg-green-600/80'} ${theme.buttonText}`}>
                                                    Select Image(s) From Device
                                                    <input type="file" ref={newItemImageFileRef} accept="image/*" multiple onChange={dataHandlers.handleItemImageUpload} className="hidden"/>
                                                </label>
                                                <button onClick={handleAddItem} className={`w-full py-2 ${theme.darkMode?'bg-green-600 hover:bg-green-700':'bg-green-500 hover:bg-green-600'} ${theme.buttonText} rounded-sm`}>Add Text/URL Item</button>
                                            </div>
                                        </div>
                                    </div>
                                    {/* Paste Items */}
                                    <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                        <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-yellow-300':'text-yellow-600'} mb-2 flex items-center gap-2`}> <ListIcon size={20}/> Paste Items</h3>
                                        <textarea ref={pasteItemsRef} rows="5" placeholder="One per line" className={`w-full p-2 mb-3 border ${theme.borderColor} rounded-sm resize-y ${theme.inputBg} ${theme.inputText}`}></textarea>
                                        <button onClick={handlePasteItems} className={`w-full py-2 ${theme.darkMode?'bg-yellow-600 hover:bg-yellow-700':'bg-yellow-500 hover:bg-yellow-600'} ${theme.buttonText} rounded-sm`}>Add Pasted</button>
                                    </div>
                                </div>
                                 {/* Item Size & Zoom */}
                                <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                    <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-purple-300':'text-purple-600'} mb-3 flex items-center gap-2`}> <MaximizeIcon size={20}/> Item Size & Zoom</h3>

                                    <div className="mb-6">
                                        <label className={`block text-sm font-medium ${theme.inputText} mb-2 text-center`}>Zoom Presets</label>
                                        <div className="flex flex-wrap gap-2 justify-center">
                                            {zoomPresets.map(p => (
                                                <button key={p.name} onClick={() => handleZoomPreset(p)} className={`px-3 py-1.5 rounded-sm shadow-sm text-sm font-semibold ${theme.buttonSecondaryBg} ${theme.buttonText}`}>
                                                    {p.name}
                                                </button>
                                            ))}
                                        </div>
                                        <div className="flex items-center gap-4 justify-center mt-3">
                                            <button onClick={() => handleZoomAdjust(0.9)} className={`p-2 rounded-full shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText}`} aria-label="Zoom Out">
                                                <ZoomOutIcon size={18}/>
                                            </button>
                                            <span className={`text-sm font-mono ${theme.inputText}`}>Fine Tune</span>
                                            <button onClick={() => handleZoomAdjust(1.1)} className={`p-2 rounded-full shadow-sm ${theme.buttonSecondaryBg} ${theme.buttonText}`} aria-label="Zoom In">
                                                <ZoomInIcon size={18}/>
                                            </button>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 items-end pt-4 border-t border-gray-500/50">
                                        <div>
                                            <label htmlFor="tierLabelWidth" className={`block text-sm font-medium ${theme.inputText}`}>Category Width (px)</label>
                                            <input type="number" id="tierLabelWidth" value={tierLabelWidth} onChange={e => setTierLabelWidth(Math.max(40, parseInt(e.target.value) || 0))} className={`mt-1 p-2 w-full border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                        </div>
                                        <div>
                                            <label htmlFor="itemWidth" className={`block text-sm font-medium ${theme.inputText}`}>Item Width (px)</label>
                                            <input type="number" id="itemWidth" value={itemWidth} onChange={e => setItemWidth(Math.max(20, parseInt(e.target.value) || 0))} className={`mt-1 p-2 w-full border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                        </div>
                                        <div>
                                            <label htmlFor="itemHeight" className={`block text-sm font-medium ${theme.inputText}`}>Item Height (px)</label>
                                            <input type="number" id="itemHeight" value={itemHeight} onChange={e => setItemHeight(Math.max(20, parseInt(e.target.value) || 0))} className={`mt-1 p-2 w-full border ${theme.borderColor} rounded-sm ${theme.inputBg} ${theme.inputText}`}/>
                                        </div>
                                        <div className="sm:col-span-2 lg:col-span-3 mt-2 flex justify-center items-center">
                                            <label htmlFor="deleteModeToggle" className={`text-sm font-medium ${theme.inputText} mr-3`}>Delete Mode</label>
                                            <div className="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                                                <input type="checkbox" name="toggle" id="deleteModeToggle" checked={deleteMode} onChange={() => setDeleteMode(!deleteMode)} className="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                                <label htmlFor="deleteModeToggle" className="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                {/* Data Management */}
                                <div className={`${theme.sectionBg} p-3 rounded-sm`}>
                                    <h3 className={`text-xl font-semibold ${theme.darkMode ? 'text-cyan-300':'text-cyan-600'} mb-2 flex items-center gap-2`}>
                                        <DownloadIcon size={20}/> Data Management
                                    </h3>
                                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
                                        <button
                                            onClick={handleNewTierList}
                                            className={`flex-1 py-2 ${theme.darkMode?'bg-green-600 hover:bg-green-700':'bg-green-500 hover:bg-green-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                        >
                                            <FilePlusIcon size={20} /> New
                                        </button>
                                        <button
                                            onClick={dataHandlers.handleOpenTierList}
                                            className={`flex-1 py-2 ${theme.darkMode?'bg-yellow-600 hover:bg-yellow-700':'bg-yellow-500 hover:bg-yellow-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                        >
                                            <FolderOpenIcon size={20} /> Open
                                        </button>
                                        <input
                                            type="file"
                                            ref={importFileRef}
                                            onChange={dataHandlers.handleImportState}
                                            className="hidden"
                                        />
                                        <button
                                            onClick={() => importFileRef.current.click()}
                                            className={`flex-1 py-2 ${theme.darkMode?'bg-cyan-600 hover:bg-cyan-700':'bg-cyan-500 hover:bg-cyan-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                        >
                                            <UploadIcon size={20} /> Import
                                        </button>
                                        <button
                                            onClick={dataHandlers.handleExportState}
                                            className={`flex-1 py-2 ${theme.darkMode?'bg-cyan-600 hover:bg-cyan-700':'bg-cyan-500 hover:bg-cyan-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                        >
                                            <DownloadIcon size={20} /> Export
                                        </button>
                                        <button
                                            onClick={dataHandlers.handleExportAllStates}
                                            className={`flex-1 py-2 ${theme.darkMode?'bg-blue-600 hover:bg-blue-700':'bg-blue-500 hover:bg-blue-600'} ${theme.buttonText} rounded-sm flex items-center justify-center gap-2`}
                                        >
                                            <DownloadCloudIcon size={20} /> Export All
                                        </button>
                                        <button
                                            onClick={handleClearAllData}
                                            className={`flex-1 py-2 bg-red-600 hover:bg-red-700 text-white rounded-sm flex items-center justify-center gap-2`}
                                        >
                                            <Trash2Icon size={20} /> Clear All Data
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                </div>
            );
        };

        function App() {
            const [appId, setAppId] = useState(() => {
                const params = new URLSearchParams(window.location.search);
                return params.get('id') || crypto.randomUUID();
            });
            const LOCAL_STORAGE_KEY = `tierListMakerState_${appId}`;

            // --- STATE INITIALIZATION LOGIC ---
            const getInitialState = () => {
                // 1. Try loading from Local Storage first (for persistence)
                const savedStateJSON = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedStateJSON) {
                    try {
                        const parsed = JSON.parse(savedStateJSON);
                        const { data, error } = validateStateData(parsed);
                        if (data) {
                            console.log("Loaded state from Local Storage.");
                            return data;
                        }
                    } catch (e) {
                        console.error("Could not parse state from Local Storage:", e);
                    }
                }

                // 2. Fallback to URL hash (for sharing)
                const { data: urlData, error: urlError } = deserializeState(window.location.hash.substring(1));
                if (urlData) {
                        console.log("Loaded state from URL.");
                    return urlData;
                }
                if(urlError){
                    // Can't use addLog here yet, so just console log
                    console.error(urlError.message);
                }

                // 3. Fallback to default state
                console.log("Using default initial state.");
                return {
                    tiers: [
                        { id: 's', type: 'name', value: 'S', items: [], color: '#ff7f7f' }, { id: 'a', type: 'name', value: 'A', items: [], color: '#ffbf7f' },
                        { id: 'b', type: 'name', value: 'B', items: [], color: '#ffff7f' }, { id: 'c', type: 'name', value: 'C', items: [], color: '#bfff7f' },
                        { id: 'd', type: 'name', value: 'D', items: [], color: '#7fbfff' },
                        { id: 'f', type: 'name', value: 'F', items: [], color: '#bf7fff' },
                    ],
                    items: [],
                    tierListTitle: 'My Tier List',
                    itemPoolTitle: 'Item Pool',
                    itemWidth: 80,
                    itemHeight: 80,
                    tierLabelWidth: 128,
                };
            };

            const initialState = getInitialState();

            // --- STATE MANAGEMENT ---
            const [darkMode, setDarkMode] = useState(true);
            const [announcement, setAnnouncement] = useState("");
            const [showClearDataModal, setShowClearDataModal] = useState(false);
            const [showOpenModal, setShowOpenModal] = useState(false);

            const [tiers, setTiers] = useState(initialState.tiers);
            const [items, setItems] = useState(initialState.items);
            const [tierListTitle, setTierListTitle] = useState(initialState.tierListTitle);
            const [itemPoolTitle, setItemPoolTitle] = useState(initialState.itemPoolTitle);
            const [itemWidth, setItemWidth] = useState(initialState.itemWidth);
            const [itemHeight, setItemHeight] = useState(initialState.itemHeight);
            const [tierLabelWidth, setTierLabelWidth] = useState(initialState.tierLabelWidth);
            const [deleteMode, setDeleteMode] = useState(false);
            const [isFullscreen, setIsFullscreen] = useState(false);
            
            const [showConfiguration, setShowConfiguration] = useState(true);
            const [showCommandsPopover, setShowCommandsPopover] = useState(false);

            // Layout state
            const [poolPosition, setPoolPosition] = useState('bottom');
            const [manualPoolPosition, setManualPoolPosition] = useState(false);
            const [tierListPanelWidth, setTierListPanelWidth] = useState(65); // Percentage
            const [isResizing, setIsResizing] = useState(false);

            const [draggedItemId, setDraggedItemId] = useState(null);
            const [draggedTierId, setDraggedTierId] = useState(null);
            const [draggedOverItemId, setDraggedOverItemId] = useState(null);
            const [draggedOverTierRowId, setDraggedOverTierRowId] = useState(null);
            const [draggedOverTierAreaId, setDraggedOverTierAreaId] = useState(null);

            // State for touch drag and drop
            const [touchInfo, setTouchInfo] = useState({
                itemId: null,
                itemData: null,
                initialX: 0,
                initialY: 0,
                currentX: 0,
                currentY: 0,
                offsetX: 0,
                offsetY: 0
            });

            // A11y State
            const [selectedItemId, setSelectedItemId] = useState(null);
            const [selectedTierId, setSelectedTierId] = useState(null);
            const lastManuallySelectedId = useRef(null);
            const lastMovedTierId = useRef(null);

            const [editingTierId, setEditingTierId] = useState(null);
            const [editingTierLabel, setEditingTierLabel] = useState('');
            const [editingTierColor, setEditingTierColor] = useState('#888888');
            const [newTierColor, setNewTierColor] = useState('#888888');

            const newTierNameRef = useRef(null);
            const newItemNameRef = useRef(null); const newItemImageFileRef = useRef(null); const newItemImageUrlRef = useRef(null);
            const pasteItemsRef = useRef(null);
            const appContainerRef = useRef(null);
            const importFileRef = useRef(null);
            const tierListRef = useRef(null); // Ref for the element to capture
            
            const standardColors = ['#ff7f7f', '#ffbf7f', '#ffff7f', '#bfff7f', '#7fbfff', '#bf7fff', '#c0c0c0', '#404040'];
            
            useEffect(() => { document.documentElement.classList.toggle('dark', darkMode); document.body.style.backgroundColor = darkMode ? '#000000' : '#f3f4f6'; }, [darkMode]);

            // Combined useEffect for saving state to URL and Local Storage
            useEffect(() => {
                const fullState = { tiers, items, tierListTitle, itemWidth, itemHeight, itemPoolTitle, tierLabelWidth };

                const timerId = setTimeout(() => {
                    // Save full state to Local Storage for persistence
                    try {
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(fullState));
                    } catch (error) {
                        console.error("Error saving state to Local Storage:", error);
                    }

                    // Save shareable state (without base64 images) to URL
                    const hashString = serializeStateForURL(fullState);
                    const newUrl = `${window.location.pathname}?id=${appId}#${hashString}`;
                    if (window.location.hash.substring(1) !== hashString || !window.location.search.includes(`id=${appId}`)) {
                        window.history.replaceState(null, '', newUrl);
                    }
                }, 700);

                return () => clearTimeout(timerId);
            }, [tiers, items, tierListTitle, itemWidth, itemHeight, itemPoolTitle, tierLabelWidth, appId, LOCAL_STORAGE_KEY]);


            const toggleFullScreen = useCallback(() => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }, []);

            useEffect(() => {
                const handleFullScreenChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFullScreenChange);
                return () => document.removeEventListener('fullscreenchange', handleFullScreenChange);
            }, []);
            
            // Handle responsive layout changes
            useEffect(() => {
                const handleResize = () => {
                    if (!manualPoolPosition) {
                        if (window.innerWidth >= 1280) {
                            setPoolPosition('right');
                        } else {
                            setPoolPosition('bottom');
                        }
                    }
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [manualPoolPosition]);

            const handleTogglePosition = () => {
                setPoolPosition(prev => prev === 'right' ? 'bottom' : 'right');
                setManualPoolPosition(true);
            };


            const generateId = useCallback(() => crypto.randomUUID(), []);

            // --- DATA HANDLERS ---
            const handleExportImage = () => {
                if (tierListRef.current) {
                    html2canvas(tierListRef.current, {
                        useCORS: true, // Important for external images
                        allowTaint: true,
                        backgroundColor: darkMode ? '#000000' : '#ffffff', // Use theme background
                        scrollX: 0,
                        scrollY: -window.scrollY
                    }).then(canvas => {
                        const link = document.createElement('a');
                        const fileName = `${tierListTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                        link.download = fileName;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    }).catch(err => {
                        console.error('html2canvas error:', err);
                    });
                }
            };

            const handleExportState = () => {
                const stateToSave = { tiers, items, tierListTitle, itemPoolTitle, itemWidth, itemHeight, tierLabelWidth };
                const jsonString = JSON.stringify(stateToSave, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const fileName = `${tierListTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.tierlist`;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleExportAllStates = () => {
                const allData = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('tierListMakerState_')) {
                        allData[key] = JSON.parse(localStorage.getItem(key));
                    }
                }

                if (Object.keys(allData).length === 0) {
                    return;
                }

                const jsonString = JSON.stringify(allData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'all_tier_lists_backup.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };


            const handleImportState = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parsedData = JSON.parse(e.target.result);
                        // Simple check to see if it's a multi-export or single
                        if (parsedData.hasOwnProperty('tiers') && parsedData.hasOwnProperty('items')) {
                            // Single file import
                            const { data, error } = validateStateData(parsedData);
                            if (error) {
                                return;
                            }
                            setTiers(data.tiers || []);
                            setItems(data.items || []);
                            setTierListTitle(data.tierListTitle);
                            setItemPoolTitle(data.itemPoolTitle);
                            setItemWidth(data.itemWidth);
                            setItemHeight(data.itemHeight);
                            setTierLabelWidth(data.tierLabelWidth);
                        } else if (Object.keys(parsedData).every(k => k.startsWith('tierListMakerState_'))) {
                            // Multi-file import
                            let importedCount = 0;
                            Object.keys(parsedData).forEach(key => {
                                const { data, error } = validateStateData(parsedData[key]);
                                if(data) {
                                    localStorage.setItem(key, JSON.stringify(data));
                                    importedCount++;
                                }
                            });
                        } else {
                            throw new Error("Invalid file format.");
                        }


                        const firstUnassignedItem = items.find(item => item.tierId === null);
                        if (firstUnassignedItem) {
                            setSelectedItemId(firstUnassignedItem.id);
                        }
                        window.scrollTo(0, 0);


                    } catch (err) {
                        console.error("Error reading file", err);
                    } finally {
                        if (importFileRef.current) {
                            importFileRef.current.value = null;
                        }
                    }
                };
                reader.onerror = () => {
                    console.error('Failed to read the file.');
                };
                reader.readAsText(file);
            };

            const handleItemImageUpload = (event) => {
                const files = event.target.files;
                if (!files || files.length === 0) return;

                let isFirstImage = true;

                Array.from(files).forEach(file => {
                    let newItem = { id: generateId(), tierId: null };
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const maxWidth = itemWidth * 2;
                            const maxHeight = itemHeight * 2;
                            let width = img.width;
                            let height = img.height;
                            if (width > height) { if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; } }
                            else { if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; } }
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            newItem.type = 'image';
                            newItem.value = canvas.toDataURL('image/jpeg', 0.8);
                            setItems(p => [...p, newItem]);
                            if (isFirstImage) {
                                setSelectedItemId(newItem.id);
                                isFirstImage = false;
                            }
                        };
                        img.src = reader.result;
                    };
                    reader.readAsDataURL(file);
                });

                window.scrollTo(0, 0);
                if (newItemImageFileRef.current) newItemImageFileRef.current.value = '';
            };

            const handleAddTier = () => {
                const name = newTierNameRef.current.value.trim();
                if (!name) { return; }
                const newTier = { id: generateId(), items: [], color: newTierColor, type: 'name', value: name };
                setTiers(p => [...p, newTier]);
                newTierNameRef.current.value = '';
            };

            const handleAddItem = () => {
                const name = newItemNameRef.current.value.trim();
                const url = newItemImageUrlRef.current.value.trim();
                if (!name && !url) { return; }
                let newItem = { id: generateId(), tierId: null };
                if (url) {
                    if (!url.startsWith('http')) { return; }
                    newItem.type = 'image'; newItem.value = url; setItems(p => [...p, newItem]);
                } else {
                    newItem.type = 'name'; newItem.value = name; setItems(p => [...p, newItem]);
                }
                newItemNameRef.current.value = '';
                if (newItemImageUrlRef.current) newItemImageUrlRef.current.value = '';
            };
            
            const handleSelectFirstItemInPool = useCallback(() => {
                const unassignedItems = items.filter(item => item.tierId === null);
                if (unassignedItems.length > 0) {
                    const firstItemId = unassignedItems[0].id;
                    // For keyboard nav, we use the other selection state
                    setSelectedItemId(firstItemId);
                    lastManuallySelectedId.current = firstItemId;
                }
            }, [items]);

            const handlePasteItems = () => {
                const text = pasteItemsRef.current.value.trim(); if (!text) { return; }
                const newItems = text.split('\n').map(l => ({ id: generateId(), type: 'name', value: l.trim(), tierId: null })).filter(i => i.value);
                setItems(p => [...p, ...newItems]); pasteItemsRef.current.value = '';
                window.scrollTo(0, 0);
                handleSelectFirstItemInPool();
            };

            const handleResetAllItemsToPool = () => {
                setItems(prevItems => prevItems.map(item => ({ ...item, tierId: null })));
                setTiers(prevTiers => prevTiers.map(tier => ({ ...tier, items: [] })));
            };

            const handleDeleteItem = (id) => { setItems(p => p.filter(i => i.id !== id)); setTiers(p => p.map(t => ({ ...t, items: t.items.filter(itemId => itemId !== id) }))); };
            const handleDeleteTier = (id) => { const tierDel = tiers.find(t=>t.id===id); if(tierDel) setItems(p=>p.map(i=>tierDel.items.includes(i.id)?{...i, tierId:null}:i)); setTiers(p => p.filter(t => t.id !== id)); if(editingTierId===id) cancelEditingTier(); };
            
            const startEditingTier = (tier) => { setEditingTierId(tier.id); setEditingTierLabel(tier.value); setEditingTierColor(tier.color); setShowConfiguration(true); };
            
            const handleSaveEditedTier = () => {
                if (!editingTierId) return;
                const updatedValue = editingTierLabel.trim();
                if (updatedValue) {
                    setTiers(p => p.map(t => t.id === editingTierId ? { ...t, value: updatedValue, color: editingTierColor } : t));
                    cancelEditingTier();
                }
            };

            const cancelEditingTier = () => { setEditingTierId(null); setEditingTierLabel(''); setEditingTierColor('#888888'); };

            const handleNewTierList = () => {
                window.open(window.location.origin + window.location.pathname, '_blank');
            };

            const handleOpenTierList = () => {
                setShowOpenModal(true);
            };

            const handleClearAllData = () => {
                setShowClearDataModal(true);
            };

            const confirmClearAllData = () => {
                localStorage.clear();
                window.location.href = window.location.origin + window.location.pathname; // Reload to a clean state
            };


            // --- DRAG & DROP + A11Y HANDLERS ---

            useEffect(() => { if (selectedItemId) setSelectedTierId(null); }, [selectedItemId]);
            useEffect(() => { if (selectedTierId) setSelectedItemId(null); }, [selectedTierId]);

            const moveItem = useCallback((itemId, targetTierId, beforeItemId = null) => {
                const itemToMove = items.find(i => i.id === itemId);
                if (!itemToMove) return;

                const sourceTierId = itemToMove.tierId;

                setItems(prev => prev.map(i => i.id === itemId ? { ...i, tierId: targetTierId } : i));

                setTiers(prevTiers => {
                    const newTiers = JSON.parse(JSON.stringify(prevTiers));

                    const sourceTier = sourceTierId ? newTiers.find(t => t.id === sourceTierId) : null;
                    const targetTier = targetTierId ? newTiers.find(t => t.id === targetTierId) : null;

                    if (sourceTier) {
                        const itemIndex = sourceTier.items.indexOf(itemId);
                        if (itemIndex > -1) {
                            sourceTier.items.splice(itemIndex, 1);
                        }
                    }

                    if (targetTier) {
                        if (beforeItemId) {
                            const targetIndex = targetTier.items.indexOf(beforeItemId);
                            if (targetIndex > -1) {
                                targetTier.items.splice(targetIndex, 0, itemId);
                            } else {
                                targetTier.items.push(itemId);
                            }
                        } else {
                            targetTier.items.push(itemId);
                        }
                    }

                    return newTiers;
                });

                const fromTierName = sourceTierId ? tiers.find(t => t.id === sourceTierId)?.value : itemPoolTitle;
                const toTierName = targetTierId ? tiers.find(t => t.id === targetTierId)?.value : itemPoolTitle;
                setAnnouncement(`Moved item from ${fromTierName} to ${toTierName}.`);
                lastManuallySelectedId.current = itemId;
            }, [items, tiers, itemPoolTitle]);

            const cleanupDragStates = () => {
                setDraggedItemId(null);
                setDraggedTierId(null);
                setDraggedOverItemId(null);
                setDraggedOverTierRowId(null);
                setDraggedOverTierAreaId(null);
                setTouchInfo({ itemId: null, itemData: null, initialX: 0, initialY: 0, currentX: 0, currentY: 0, offsetX: 0, offsetY: 0 });
            };

            const handleItemDragStart = (e, itemId) => {
                setDraggedItemId(itemId);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', itemId);
            };

            const handleTierLabelDragStart = (e, tierId) => {
                setDraggedTierId(tierId);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', tierId);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleTierRowDragOver = (e, targetTierId) => {
                e.preventDefault();
                if (draggedTierId && draggedTierId !== targetTierId) {
                    setDraggedOverTierRowId(targetTierId);
                }
            };

            const handleTierRowDragLeave = (e) => {
                 setDraggedOverTierRowId(null);
            };

            const handleTierAreaDragEnter = (e, tierId) => {
                e.preventDefault();
                if(draggedItemId) {
                    setDraggedOverTierAreaId(tierId);
                    setDraggedOverItemId(null);
                }
            };

            const handleTierAreaDragLeave = (e) => {
                setDraggedOverTierAreaId(null);
            };

            const handleItemDragEnter = (e, targetItemId, targetItemTierId) => {
                e.preventDefault();
                if (draggedItemId && draggedItemId !== targetItemId) {
                    setDraggedOverItemId(targetItemId);
                    setDraggedOverTierAreaId(targetItemTierId);
                }
            };

            const handleItemDragLeave = (e) => {
                setDraggedOverItemId(null);
            };

            const handleDrop = (e, targetTierId, beforeItemId = null) => {
                e.preventDefault();
                e.stopPropagation();

                const droppedId = e.dataTransfer.getData('text/plain');

                // Check if we are dropping a tier
                if (tiers.some(t => t.id === droppedId)) {
                    if (draggedTierId && draggedTierId !== targetTierId) {
                        setTiers(prev => {
                            const dTier = prev.find(t => t.id === draggedTierId);
                            if (!dTier) return prev;
                            const remaining = prev.filter(t => t.id !== dTierId);
                            const targetIdx = remaining.findIndex(t => t.id === targetTierId);
                            if (targetIdx !== -1) {
                                remaining.splice(targetIdx, 0, dTier);
                            }
                            return remaining;
                        });
                    }
                }
                // Check if we are dropping an item
                else if (items.some(i => i.id === droppedId)) {
                    moveItem(droppedId, targetTierId, beforeItemId);
                }

                cleanupDragStates();
            };

            // --- Touch Handlers ---
            const handleTouchStart = (e, item) => {
                if (e.touches.length !== 1) return;
                // Prevent default behavior like scrolling or text selection
                e.preventDefault();
                const touch = e.touches[0];
                const rect = e.currentTarget.getBoundingClientRect();

                setDraggedItemId(item.id); // Use existing state for visual feedback (opacity)

                setTouchInfo({
                    itemId: item.id,
                    itemData: item,
                    initialX: touch.clientX,
                    initialY: touch.clientY,
                    currentX: touch.clientX,
                    currentY: touch.clientY,
                    offsetX: touch.clientX - rect.left,
                    offsetY: touch.clientY - rect.top,
                });
            };

            useEffect(() => {
                const handleTouchMove = (e) => {
                    if (e.touches.length !== 1 || !touchInfo.itemId) return;
                    e.preventDefault();
                    const touch = e.touches[0];

                    setTouchInfo(prev => ({ ...prev, currentX: touch.clientX, currentY: touch.clientY }));

                    const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (!elementOver) {
                        setDraggedOverItemId(null);
                        setDraggedOverTierAreaId(null);
                        return;
                    }

                    const dropTargetItem = elementOver.closest(`[id^="item-"]`);
                    const dropTargetTierArea = elementOver.closest('[data-droptarget-tier-id]');

                    if (dropTargetItem && dropTargetItem.id !== `item-${touchInfo.itemId}`) {
                        const targetItemId = dropTargetItem.id.replace('item-', '');
                        const targetItem = items.find(i => i.id === targetItemId);
                        if (targetItem) {
                            setDraggedOverItemId(targetItemId);
                            setDraggedOverTierAreaId(targetItem.tierId);
                        }
                    } else if (dropTargetTierArea) {
                        const tierIdStr = dropTargetTierArea.dataset.droptargetTierId;
                        setDraggedOverTierAreaId(tierIdStr === 'null' ? null : tierIdStr);
                        setDraggedOverItemId(null);
                    } else {
                        setDraggedOverItemId(null);
                        setDraggedOverTierAreaId(null);
                    }
                };

                const handleTouchEnd = (e) => {
                    if (!touchInfo.itemId) return;

                    const touch = e.changedTouches[0];
                    const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);

                    let finalTargetTierId = null;
                    let finalBeforeItemId = null;

                    if (elementOver) {
                        const dropTargetItem = elementOver.closest(`[id^="item-"]`);
                        const dropTargetTierArea = elementOver.closest('[data-droptarget-tier-id]');

                        if (dropTargetItem && dropTargetItem.id !== `item-${touchInfo.itemId}`) {
                            const targetItemId = dropTargetItem.id.replace('item-', '');
                            const targetItem = items.find(i => i.id === targetItemId);
                            if (targetItem) {
                                finalBeforeItemId = targetItemId;
                                finalTargetTierId = targetItem.tierId;
                            }
                        } else if (dropTargetTierArea) {
                            const tierIdStr = dropTargetTierArea.dataset.droptargetTierId;
                            finalTargetTierId = tierIdStr === 'null' ? null : tierIdStr;
                        }
                    }

                    moveItem(touchInfo.itemId, finalTargetTierId, finalBeforeItemId);
                    cleanupDragStates();
                };

                if (touchInfo.itemId) {
                    window.addEventListener('touchmove', handleTouchMove, { passive: false });
                    window.addEventListener('touchend', handleTouchEnd);
                    window.addEventListener('touchcancel', handleTouchEnd);
                }

                return () => {
                    window.removeEventListener('touchmove', handleTouchMove);
                    window.removeEventListener('touchend', handleTouchEnd);
                    window.removeEventListener('touchcancel', handleTouchEnd);
                };
            }, [touchInfo.itemId, items, moveItem]);


            const handleItemClick = useCallback((itemId) => {
                setSelectedItemId(prevSelectedId => {
                    if (prevSelectedId === itemId) {
                        setAnnouncement(`Item deselected.`);
                        return null;
                    } else {
                        const item = items.find(i => i.id === itemId);
                        if (item) {
                            setAnnouncement(`Item ${item.value || 'image'} selected. Use arrow keys to move, or Escape to deselect.`);
                            return itemId;
                        }
                        return prevSelectedId;
                    }
                });
            }, [items]);

            const handleTierClick = useCallback((tierId) => {
                setSelectedTierId(prevSelectedId => {
                    if (prevSelectedId === tierId) {
                        setAnnouncement(`Tier deselected.`);
                        return null;
                    } else {
                        const tier = tiers.find(t => t.id === tierId);
                        if (tier) {
                            setAnnouncement(`Tier ${tier.value} selected. Use arrow keys to reorder, or Escape to deselect.`);
                            return tierId;
                        }
                        return prevSelectedId;
                    }
                });
            }, [tiers]);

            const handleSelectNextItemInPool = useCallback(() => {
                const unassignedItems = items.filter(item => item.tierId === null);
                if (unassignedItems.length === 0) {
                    return;
                }
                const currentSelectedIndexInPool = unassignedItems.findIndex(item => item.id === selectedItemId);
                let nextItem;
                if (currentSelectedIndexInPool !== -1 && currentSelectedIndexInPool < unassignedItems.length - 1) {
                    nextItem = unassignedItems[currentSelectedIndexInPool + 1];
                } else {
                    nextItem = unassignedItems[0];
                }
                if (nextItem) {
                    handleItemClick(nextItem.id);
                    lastManuallySelectedId.current = nextItem.id;
                }
            }, [items, selectedItemId, handleItemClick]);


            useEffect(() => {
                const handleKeyDown = (e) => {
                    const activeElement = document.activeElement;
                    if (!activeElement || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    if (e.key === '/' || e.key === '?') {
                        e.preventDefault();
                        setShowCommandsPopover(prev => !prev);
                        return;
                    }

                    if (showCommandsPopover) return;

                    if (e.key.toLowerCase() === 'f') { e.preventDefault(); toggleFullScreen(); return; }
                    
                    if (['n', 'e'].includes(e.key.toLowerCase())) {
                        e.preventDefault();
                        handleSelectNextItemInPool();
                        return;
                    }

                    if (!activeElement.id) return;
                    const [type, id] = activeElement.id.split(/-(.+)/);
                    if (!id) return;
                    const keyMap = { 'w': 'ArrowUp', 'a': 'ArrowLeft', 's': 'ArrowDown', 'd': 'ArrowRight' };
                    const mappedKey = keyMap[e.key.toLowerCase()] || e.key;
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        if (type === 'item') handleItemClick(id); else if (type === 'tierlabel') handleTierClick(id);
                        return;
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (selectedItemId) { lastManuallySelectedId.current = selectedItemId; handleItemClick(selectedItemId); }
                        else if (selectedTierId) { lastMovedTierId.current = selectedTierId; handleTierClick(selectedTierId); }
                        return;
                    }
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(mappedKey)) {
                        e.preventDefault();
                        if (selectedItemId) {
                            const item = items.find(i => i.id === selectedItemId);
                            if (!item) return;
                            const currentTierId = item.tierId;
                            if (mappedKey === 'ArrowUp' || mappedKey === 'ArrowDown') {
                                const tierIds = [null, ...tiers.map(t => t.id)];
                                const currentTierIndex = tierIds.indexOf(currentTierId);
                                let nextTierIndex = mappedKey === 'ArrowUp' ? (currentTierIndex > 0 ? currentTierIndex - 1 : tierIds.length - 1) : (currentTierIndex < tierIds.length - 1 ? currentTierIndex + 1 : 0);
                                const nextTierId = tierIds[nextTierIndex];
                                moveItem(selectedItemId, nextTierId);
                            } else {
                                setTiers(prevTiers => prevTiers.map(tier => {
                                    if (tier.id === currentTierId) {
                                        const itemIndex = tier.items.indexOf(selectedItemId);
                                        if (itemIndex === -1) return tier;
                                        const newItems = [...tier.items];
                                        const newIndex = mappedKey === 'ArrowLeft' ? Math.max(0, itemIndex - 1) : Math.min(newItems.length - 1, itemIndex + 1);
                                        if (newIndex !== itemIndex) {
                                            [newItems[itemIndex], newItems[newIndex]] = [newItems[newIndex], newItems[itemIndex]];
                                            setAnnouncement(`Item moved ${mappedKey === 'ArrowLeft' ? 'left' : 'right'}.`);
                                            lastManuallySelectedId.current = selectedItemId;
                                        }
                                        return { ...tier, items: newItems };
                                    }
                                    return tier;
                                }));
                            }
                        } else if (selectedTierId) {
                            if (mappedKey === 'ArrowUp' || mappedKey === 'ArrowDown') {
                                setTiers(prev => {
                                    const tierIndex = prev.findIndex(t => t.id === selectedTierId);
                                    if (tierIndex === -1) return prev;
                                    const newIndex = mappedKey === 'ArrowUp' ? Math.max(0, tierIndex - 1) : Math.min(prev.length - 1, tierIndex + 1);
                                    if (newIndex !== tierIndex) {
                                        const newTiers = [...prev];
                                        const [movedTier] = newTiers.splice(tierIndex, 1);
                                        newTiers.splice(newIndex, 0, movedTier);
                                        setAnnouncement(`Tier moved ${mappedKey === 'ArrowUp' ? 'up' : 'down'}.`);
                                        lastMovedTierId.current = selectedTierId;
                                        return newTiers;
                                    }
                                    return prev;
                                });
                            }
                        } else {
                            handleNavigation(mappedKey, activeElement.id);
                        }
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [selectedItemId, selectedTierId, items, tiers, moveItem, handleItemClick, handleTierClick, handleSelectNextItemInPool, toggleFullScreen, showCommandsPopover]);

            const { focusableGrid, focusableMap } = useMemo(() => {
                const grid = []; const map = {};
                tiers.forEach((tier) => { const row = [`tier-label-${tier.id}`]; tier.items.forEach(itemId => { row.push(`item-${itemId}`); }); grid.push(row); });
                const unassignedItems = items.filter(item => item.tierId === null);
                if (unassignedItems.length > 0) { grid.push(unassignedItems.map(item => `item-${item.id}`)); }
                grid.forEach((row, rowIndex) => { row.forEach((id, colIndex) => { map[id] = { row: rowIndex, col: colIndex }; }); });
                return { focusableGrid: grid, focusableMap: map };
            }, [tiers, items]);

            const handleNavigation = (key, currentId) => {
                if (!focusableMap[currentId]) return;
                const { row: currentRow, col: currentCol } = focusableMap[currentId];
                let nextRow = currentRow, nextCol = currentCol;
                switch (key) {
                    case 'ArrowUp': nextRow = currentRow > 0 ? currentRow - 1 : focusableGrid.length - 1; break;
                    case 'ArrowDown': nextRow = currentRow < focusableGrid.length - 1 ? currentRow + 1 : 0; break;
                    case 'ArrowLeft': if (currentCol > 0) nextCol = currentCol - 1; break;
                    case 'ArrowRight': if (currentCol < focusableGrid[currentRow].length - 1) nextCol = currentCol + 1; break;
                    default: return;
                }
                if (key === 'ArrowUp' || key === 'ArrowDown') { nextCol = Math.min(currentCol, focusableGrid[nextRow].length - 1); }
                const nextId = focusableGrid[nextRow]?.[nextCol];
                if (nextId) { const nextElement = document.getElementById(nextId); if (nextElement) nextElement.focus(); }
            };

            useEffect(() => {
                if (lastManuallySelectedId.current) { const el = document.getElementById(`item-${lastManuallySelectedId.current}`); if (el) el.focus(); lastManuallySelectedId.current = null; }
                if (lastMovedTierId.current) { const el = document.getElementById(`tier-label-${lastMovedTierId.current}`); if (el) el.focus(); lastMovedTierId.current = null; }
            }, [items, tiers]);

             useEffect(() => { if (selectedItemId && document.activeElement?.id !== `item-${selectedItemId}`) { const el = document.getElementById(`item-${selectedItemId}`); if (el) el.focus(); } }, [selectedItemId]);

            const handleResizeMouseDown = (e) => {
                e.preventDefault();
                setIsResizing(true);
            };

            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!isResizing) return;
                    const containerRect = appContainerRef.current.getBoundingClientRect();
                    const newWidthPercent = ((e.clientX - containerRect.left) / containerRect.width) * 100;
                    // Constrain the panel width between 50% and 80% for the tier list
                    const constrainedWidth = Math.max(50, Math.min(80, newWidthPercent));
                    setTierListPanelWidth(constrainedWidth);
                };

                const handleMouseUp = () => {
                    setIsResizing(false);
                };

                if (isResizing) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                }

                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizing]);

            const theme = { 
                darkMode, 
                bg: darkMode ? 'bg-black' : 'bg-gray-100', 
                text: darkMode ? 'text-gray-100' : 'text-gray-900', 
                containerBg: darkMode ? 'bg-gray-800' : 'bg-white', 
                itemBg: darkMode ? 'bg-gray-700' : 'bg-gray-50',
                inputBg: darkMode ? 'bg-gray-700' : 'bg-gray-50', 
                inputText: darkMode ? 'text-gray-200' : 'text-gray-800', 
                placeholderText: darkMode ? 'placeholder-gray-400' : 'placeholder-gray-500', 
                borderColor: darkMode ? 'border-gray-600' : 'border-gray-300', 
                buttonPrimaryBg: darkMode ? 'bg-blue-600 hover:bg-blue-700' : 'bg-blue-500 hover:bg-blue-600', 
                buttonSecondaryBg: darkMode ? 'bg-gray-600 hover:bg-gray-700' : 'bg-gray-500 hover:bg-gray-600', 
                buttonText: 'text-white', 
                sectionBg: darkMode ? 'bg-gray-800' : 'bg-white', 
            };
            const dragState = { draggedItemId, draggedTierId, draggedOverItemId, draggedOverTierRowId, draggedOverTierAreaId, selectedItemId, selectedTierId };
            const itemProps = { itemWidth, itemHeight, tierLabelWidth };
            const itemSetters = { setItemWidth, setItemHeight, setTierLabelWidth };
            const allHandlers = {
                handleItemDragStart, handleTierLabelDragStart, handleDragOver, handleTierRowDragOver, handleTierRowDragLeave,
                handleTierAreaDragEnter, handleTierAreaDragLeave, handleItemDragEnter, handleItemDragLeave, handleDrop,
                cleanupDragStates, handleDeleteItem, handleDeleteTier, startEditingTier, handleAddItem, handlePasteItems,
                handleResetAllItemsToPool, handleSaveEditedTier, cancelEditingTier, handleExportState, handleImportState,
                handleItemImageUpload, handleExportImage, handleItemClick, handleTierClick, handleClearAllData,
                handleNewTierList, handleExportAllStates, handleOpenTierList, handleAddTier, handleTouchStart
            };
            const uiState = { showConfiguration, editingTierId };
            const uiSetters = { setShowConfiguration, handleSelectFirstItemInPool };
            const data = { standardColors };
            const editState = { editingTierLabel, editingTierColor, newTierColor };
            const editSetters = { setEditingTierLabel, setEditingTierColor, setNewTierColor };
            const refs = { newTierNameRef, newItemNameRef, newItemImageFileRef, newItemImageUrlRef, pasteItemsRef, importFileRef };

            const isSideLayout = poolPosition === 'right';

                        return (
                            <div
                                className={`min-h-screen font-sans transition-colors duration-300 ${theme.bg} ${theme.text}`}
                            >
                                <DragPreview
                                    item={touchInfo.itemData}
                                    itemWidth={itemWidth}
                                    itemHeight={itemHeight}
                                    position={touchInfo.itemId ? { x: touchInfo.currentX - touchInfo.offsetX, y: touchInfo.currentY - touchInfo.offsetY } : null}
                                    theme={theme}
                                />
                                {showCommandsPopover && <CommandsPopover theme={theme} onClose={() => setShowCommandsPopover(false)} />}
                                {showClearDataModal && <ConfirmationModal theme={theme} onConfirm={confirmClearAllData} onCancel={() => setShowClearDataModal(false)} title="Clear All Data?" message="This will permanently delete all tiers and items from your browser's storage and cannot be undone."/>}
                                {showOpenModal && <OpenTierListModal theme={theme} onClose={() => setShowOpenModal(false)} />}
                                <div aria-live="assertive" style={{ position: 'absolute', width: '1px', height: '1px', padding: '0', margin: '-1px', overflow: 'hidden', clip: 'rect(0, 0, 0, 0)', whiteSpace: 'nowrap', border: '0' }}>{announcement}</div>

                                <div ref={appContainerRef} className="mx-auto max-w-full flex flex-col gap-1 p-1">
                                    <div className={`relative ${theme.containerBg}`}>
                                        <button
                                            onClick={() => setShowCommandsPopover(true)}
                                            className={`absolute top-4 right-4 p-2 rounded-full z-20 ${theme.darkMode ? 'text-gray-400 hover:bg-gray-700 hover:text-white' : 'text-gray-500 hover:bg-gray-200 hover:text-black'}`}
                                            aria-label="Show keyboard commands"
                                        >
                                            <HelpCircleIcon size={28} />
                                        </button>
                                        <input type="text" value={tierListTitle} onChange={(e) => setTierListTitle(e.target.value)} className={`text-3xl sm:text-4xl font-extrabold bg-transparent border-none focus:outline-none focus:ring-0 text-center w-full p-4 ${theme.text}`} aria-label="Tier list title"/>
                                    </div>

                                    <div className={`flex ${isSideLayout ? 'flex-row' : 'flex-col gap-1'}`}>
                                        <div
                                            className="tier-list-container"
                                            style={isSideLayout ? { width: `${tierListPanelWidth}%` } : { width: '100%' }}
                                        >
                                            <div ref={tierListRef} className="w-full flex flex-col gap-1">
                                                {tiers.map((tier, index) => (
                                                    <TierRow key={tier.id} tier={tier} items={items} theme={theme} dragState={dragState} handlers={allHandlers} itemProps={itemProps} deleteMode={deleteMode} selectedTierId={selectedTierId} />
                                                ))}
                                            </div>
                                            {!isSideLayout && (
                                                <div className='mt-1'>
                                                    <ItemPool items={items} itemPoolTitle={itemPoolTitle} setItemPoolTitle={setItemPoolTitle} theme={theme} dragState={dragState} handlers={allHandlers} itemProps={itemProps} deleteMode={deleteMode} poolPosition={poolPosition} onTogglePosition={handleTogglePosition} />
                                                </div>
                                            )}
                                        </div>

                                        {isSideLayout && (
                                            <>
                                                <div onMouseDown={handleResizeMouseDown} className={`w-1 cursor-col-resize flex-shrink-0 ${theme.bg} hover:bg-blue-500/50 transition-colors`}></div>
                                                <div
                                                    className="item-pool-container flex-grow"
                                                    style={{ width: `${100 - tierListPanelWidth}%` }}
                                                >
                                                    <ItemPool items={items} itemPoolTitle={itemPoolTitle} setItemPoolTitle={setItemPoolTitle} theme={theme} dragState={dragState} handlers={allHandlers} itemProps={itemProps} deleteMode={deleteMode} poolPosition={poolPosition} onTogglePosition={handleTogglePosition} />
                                                </div>
                                            </>
                                        )}
                                    </div>

                                    <ConfigurationPanel theme={theme} uiState={uiState} uiSetters={uiSetters} data={data} dataHandlers={allHandlers} editState={editState} editSetters={editSetters} refs={refs} itemProps={itemProps} itemSetters={itemSetters} deleteMode={deleteMode} setDeleteMode={setDeleteMode} setContainerWidth={() => {}} toggleFullScreen={toggleFullScreen} setDarkMode={setDarkMode} isFullscreen={isFullscreen} darkMode={darkMode} />
                                </div>
                            </div>
                        );
                    }

                    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
                </script>
            </body>
            </html>
            